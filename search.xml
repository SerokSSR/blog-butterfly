<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图上动态规划：DFS、状压、树形</title>
      <link href="dp-graph/"/>
      <url>dp-graph/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>几乎所有的DP都可以转化为搜索。当想不出正解时，DFS也是骗分的好手段。</p><p>主要的搜索手段有：</p><ol><li>DFS/BFS爆搜</li><li>双向BFS</li><li>启发式搜索（又称A*）</li><li>迭代加深搜索</li><li>IDA*（迭代加深+启发式）</li><li>记忆化搜索</li><li>剪枝</li></ol><p>重要程度：1,7,6 - 4,3 - 5,2。</p><p><del>下面这几道题都是去年当时不会做的，结果一年过去了，还是不会，呜呜呜</del></p><h3 id="P3956-棋盘"><a href="#P3956-棋盘" class="headerlink" title="P3956 棋盘"></a>P3956 棋盘</h3><p>NOIp 2017 普及</p><p>搜索裸题</p><p>显然不可以用vis[]来判断，因此<b>会搜到重复的状态</b>，考虑记忆化搜索。</p><p>网上的题解好像都没有正确性证明，可能觉得太显然了？可我就在这里卡了好久啊 /kk</p><ul><li>如果当前格子本来就有颜色，那么魔法一定可用</li><li>如果当前格子原本没有颜色，那么只要搜到这个格子，魔法其实<b>只有一种情况</b>就是不可用</li></ul><p>而且记搜的时候注意剪枝条件一定要<b>写到上界！</b>比如下面这段代码，<code>f &gt;= mem[x][y]</code> 如果改成 <code>f &gt; mem[x][y]</code>，100直接变70……</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 110;int m, n, c[N][N], mem[N][N];int d[4][2] &#x3D; &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;;int ans &#x3D; 0x3f3f3f3f;void dfs(int x, int y, int f, int cc) &#123;        &#x2F;&#x2F;f: 代价    &#x2F;&#x2F;cc !&#x3D; -1 不能用魔法, 此处改成的颜色    &#x2F;&#x2F;cc &#x3D;&#x3D; -1 可以        if(f &gt;&#x3D; mem[x][y] || f &gt;&#x3D; mem[m][m]) return;    mem[x][y] &#x3D; f;        if(x &#x3D;&#x3D; m &amp;&amp; y &#x3D;&#x3D; m) return;        for(int i&#x3D;0; i&lt;4; ++i) &#123;        int xx&#x3D;x+d[i][0],yy&#x3D;y+d[i][1];        if(xx&lt;1||xx&gt;m||yy&lt;1||yy&gt;m) continue;        if(cc!&#x3D;-1&amp;&amp;c[xx][yy]&#x3D;&#x3D;cc||cc&#x3D;&#x3D;-1&amp;&amp;c[xx][yy]&#x3D;&#x3D;c[x][y]) &#123;            dfs(xx, yy, f, -1);        &#125; else if(cc!&#x3D;-1&amp;&amp;c[xx][yy]!&#x3D;cc&amp;&amp;c[xx][yy]!&#x3D;-1||cc&#x3D;&#x3D;-1&amp;&amp;c[xx][yy]!&#x3D;c[x][y]&amp;&amp;c[xx][yy]!&#x3D;-1) &#123;            dfs(xx, yy, f+1, -1);         &#125; else if(cc&#x3D;&#x3D;-1&amp;&amp;c[xx][yy]&#x3D;&#x3D;-1) &#123;            dfs(xx, yy, f+2, c[x][y]);        &#125;    &#125;&#125;int main() &#123;        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);        memset(c, -1, sizeof c);    memset(mem, 0x3f, sizeof mem);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;         int x, y, cc; scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;cc);         c[x][y] &#x3D; cc;    &#125;        dfs(1, 1, 0, -1);        printf(&quot;%d\n&quot;, mem[m][m] &#x3D;&#x3D; 0x3f3f3f3f ? -1 : mem[m][m]);    return 0;&#125;</code></pre><h3 id="P3959-宝藏"><a href="#P3959-宝藏" class="headerlink" title="P3959 宝藏"></a>P3959 宝藏</h3><p>NOIp 2017 提高</p><p><del>去年做的时候就连70分做法都不会。一年过去了，还是不会，呜呜呜</del></p><p>（下面为自己开脱）</p><p>这道题的部分分思想其实还挺重要的。</p><p>我们知道，一般的DFS就是在找出很多单条路径的过程中，获得最优答案。形式也很固定，一般形如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void&#x2F;int dfs(int u, int sum, int cnt, ...)</code></pre><p><b>而这道题不然。</b></p><p>从样例二就可以看出，最终合法方案呈<b>树形</b>，而不是单条<b>路径</b>。初步想到生成树，但是假掉了。、</p><h4 id="反例："><a href="#反例：" class="headerlink" title="反例："></a>反例：</h4><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/images/2020/08/10/d6de2d2b502ed79d81abe9ebb16d40d1.png"></p><p>这张图从1号点开始的Prim便是错的。</p><p>如果跑Prim，从1号点开始的话，我们会先访问2，（此时花费为1），然后我们会访问3，此时花费为3 * 2，然后由于只有4号点未访问，这时3号的访问顺序为3，访问4号的代价是3 * 100 = 300，显然这种做法不是最优的，正确的答案应该是211（从1号点开始的最小花费为211）。</p><p>虽然直接跑Prim是错的，但是Prim的思想仍然重要，这一思想也在最短路等很多算法中有应用：用更新过的点去更新其他点。</p><p>我们设计一个<b>不基于点</b>的dfs函数，参数只需传递代价，每次迭代，先枚举访问过的点，再枚举一个未访问且未开通路径的点，进行松弛，将代价持续传递下去。计算代价需要记录点的深度，也要通过父节点传递下去。</p><p>代码不长，也不难写，说是白给70分，其实思路并不好想（虽然比正解 $O(n \times 3^n)$ 状压好写多了）。毕竟是紫题嘛，像我这种菜鸡也不打算AC，能骗多少是多少。</p><p>总的来说，这道题的关键还是在于生成树，需要认真看题，熟练运用普及算法（</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cstring&gt;const int INF &#x3D; 0x7f7f7f7f;int min(int a, int b) &#123; return a &lt; b ? a : b; &#125;int map[20][20];int dep[20], best, n, m, num;bool vis[20];void dfs(int x) &#123;    if(x &gt;&#x3D; best) return;    if(num &#x3D;&#x3D; 0) &#123;        best &#x3D; x;        return;    &#125;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        if(vis[i]) &#123;            for(int j&#x3D;1; j&lt;&#x3D;n; ++j) &#123;                if(!vis[j] and map[i][j] &lt; INF) &#123;                    vis[j] &#x3D; true; --num;                    dep[j] &#x3D; dep[i] + 1;                    dfs(x + map[i][j] * dep[j]);                    vis[j] &#x3D; false; ++num;                &#125;            &#125;        &#125;    &#125;&#125;int main() &#123;    memset(map, 0x7f, sizeof map);        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for(int i&#x3D;1; i&lt;&#x3D;m; ++i) &#123;        int x, y, v;        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;v);        map[x][y] &#x3D; map[y][x] &#x3D; min(map[x][y], v);    &#125;        best &#x3D; INF; num &#x3D; n;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        vis[i] &#x3D; true; --num;        dep[i] &#x3D; 0;        dfs(0);        vis[i] &#x3D; false; ++num;    &#125;        printf(&quot;%d\n&quot;, best);        return 0;&#125;</code></pre><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>设全集为 $x$</p><ul><li><code>for(int y = x; y; y = (y-1) &amp; x)</code>：枚举 x 的每个子集</li><li><code>x^y</code>：x 集合中刨去 y</li><li><code>x&amp;y == y</code>：y 是 x 的子集</li></ul><h3 id="P3052-USACO12MAR-Cows-in-a-Skyscraper-G"><a href="#P3052-USACO12MAR-Cows-in-a-Skyscraper-G" class="headerlink" title="P3052 [USACO12MAR]Cows in a Skyscraper G"></a>P3052 [USACO12MAR]Cows in a Skyscraper G</h3><h2 id="树形-DP"><a href="#树形-DP" class="headerlink" title="树形 DP"></a>树形 DP</h2><h3 id="P1352-没有上司的舞会"><a href="#P1352-没有上司的舞会" class="headerlink" title="P1352 没有上司的舞会"></a>P1352 没有上司的舞会</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef vector&lt;int&gt;::iterator IT;const int N &#x3D; 6e3 + 10;int fa[N]; vector&lt;int&gt; g[N];int n, r[N];inline int fin() &#123;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) if(!fa[i]) return i;&#125;int f[N][2];&#x2F;&#x2F; 0&#x2F;1void dfs(int u) &#123;    f[u][0] &#x3D; 0;    f[u][1] &#x3D; r[u];    for(IT it &#x3D; g[u].begin(); it !&#x3D; g[u].end(); ++it) &#123;        dfs(*it);        f[u][0] +&#x3D; max(f[*it][0], f[*it][1]);        f[u][1] +&#x3D; f[*it][0];    &#125;&#125;int main() &#123;        scanf(&quot;%d&quot;, &amp;n);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) scanf(&quot;%d&quot;, r+i);    for(int i&#x3D;1; i&lt;n; ++i) &#123; int l, k;        scanf(&quot;%d%d&quot;, &amp;l, &amp;k); fa[l] &#x3D; k;        g[k].push_back(l);    &#125;    int rt &#x3D; fin();    dfs(rt);    printf(&quot;%d&quot;, max(f[rt][0], f[rt][1]));    return 0;&#125;</code></pre><h3 id="P2014-CTSC1997-选课"><a href="#P2014-CTSC1997-选课" class="headerlink" title="P2014 [CTSC1997]选课"></a>P2014 [CTSC1997]选课</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N &#x3D; 330;vector&lt;int&gt; g[N];int n, m; int dp[N][N];void dfs(int u) &#123;    for(vector&lt;int&gt;::iterator it &#x3D; g[u].begin(); it !&#x3D; g[u].end(); it++) &#123;        dfs(*it);        for(int j&#x3D;m+1; j&gt;1; --j) &#123;            for(int k&#x3D;0; k&lt;j; ++k)                dp[u][j] &#x3D; max(dp[u][j], dp[*it][k] + dp[u][j-k]);        &#125;    &#125;&#125;int main() &#123;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123; int k;        scanf(&quot;%d%d&quot;, &amp;k, &amp;dp[i][1]);        g[k].push_back(i);    &#125;    dfs(0);    printf(&quot;%d\n&quot;, dp[0][m+1]);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> 图论 </tag>
            
            <tag> 树 </tag>
            
            <tag> DFS </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列动态规划：区间 DP &amp; 背包</title>
      <link href="dp-series/"/>
      <url>dp-series/</url>
      
        <content type="html"><![CDATA[<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><ol><li>递归，从后向前</li><li>预处理</li><li>划分子结构</li><li>单调队列、滑动窗口</li><li><b>能剪的枝一定要减！能剪的枝一定要减！能剪的枝一定要减！</b></li><li>但是剪枝别剪挂了……</li></ol><h3 id="手动扩栈"><a href="#手动扩栈" class="headerlink" title="手动扩栈"></a>手动扩栈</h3><p>编译时指定参数</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">-Wl,--stack&#x3D;size </code></pre><p>size是栈的大小，单位为字节。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/images/2020/10/10/f016d8da5ea39bdb543c2b52c2fe501f.png"><br><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/images/2020/10/10/9b025b0dcf84f22da77e77f039bd78e5.png"></p><h2 id="经典区间-DP"><a href="#经典区间-DP" class="headerlink" title="经典区间 DP"></a>经典区间 DP</h2><h3 id="P1880-NOI1995-石子合并"><a href="#P1880-NOI1995-石子合并" class="headerlink" title="P1880 [NOI1995]石子合并"></a>P1880 [NOI1995]石子合并</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 220;int ans, dp[N][N], n, a[N], s[N];int main() &#123;        scanf(&quot;%d&quot;, &amp;n);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        scanf(&quot;%d&quot;, a+i);        s[i] &#x3D; s[i-1] + a[i];    &#125;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        s[i+n] &#x3D; s[i+n-1] + a[i];    &#125;    memset(dp, 0x3f, sizeof dp);    for(int i&#x3D;1; i&lt;&#x3D;2*n; ++i) dp[i][i] &#x3D; 0;    for(int l&#x3D;2; l&lt;&#x3D;n; ++l) &#123;        for(int i&#x3D;1, j&#x3D;l; j&lt;&#x3D;2*n; ++i, ++j) &#123;            for(int k&#x3D;i; k&lt;j; ++k) &#123;                dp[i][j] &#x3D; min(dp[i][j], dp[i][k] + dp[k+1][j] + s[j] - s[i-1]);            &#125;        &#125;    &#125;    ans &#x3D; 0x3f3f3f3f;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        &#x2F;&#x2F;printf(&quot;%d &quot;, dp[i][i+n-1]);        ans &#x3D; min(ans, dp[i][i+n-1]);    &#125;    printf(&quot;%d\n&quot;, ans);        memset(dp, 0, sizeof dp);    for(int i&#x3D;1; i&lt;&#x3D;2*n; ++i) dp[i][i] &#x3D; 0;    for(int l&#x3D;2; l&lt;&#x3D;n; ++l) &#123;        for(int i&#x3D;1, j&#x3D;l; j&lt;&#x3D;2*n; ++i, ++j) &#123;            for(int k&#x3D;i; k&lt;j; ++k) &#123;                dp[i][j] &#x3D; max(dp[i][j], dp[i][k] + dp[k+1][j] + s[j] - s[i-1]);            &#125;        &#125;    &#125;    ans &#x3D; 0;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        ans &#x3D; max(ans, dp[i][i+n-1]);    &#125;    printf(&quot;%d\n&quot;, ans);    return 0;&#125;</code></pre><h3 id="P5665-CSP-S-2019-划分"><a href="#P5665-CSP-S-2019-划分" class="headerlink" title="P5665 [CSP-S-2019]划分"></a>P5665 [CSP-S-2019]划分</h3><p>DP思路：先固定一个在后面的点，然后通过枚举前面的点来求答案。</p><p>感觉好像很好想，又好像很难想到……不知道考场上会不会想到，总觉得大概率不会吧。</p><p>分析了一下去年的题目，$100+35+10+24+24+0=193$ 的裸暴力分，去年已经是足够1=了</p><p>不过今年限制只有高中的能参赛了。。。感觉压力好大</p><p>不管了，努力吧</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int N &#x3D; 550000;typedef long long LL;LL ans &#x3D; 0, a[N], s[N], last[N], dp[N];int n, type;int main() &#123;    &#x2F;&#x2F;freopen(&quot;partition.in&quot;, &quot;r&quot;, stdin);&#x2F;&#x2F;freopen(&quot;partition.out&quot;, &quot;w&quot;, stdout);        scanf(&quot;%d%d&quot;, &amp;n, &amp;type);        if(type &#x3D;&#x3D; 0) &#123;                for(int i&#x3D;1; i&lt;&#x3D;n; ++i) scanf(&quot;%lld&quot;, a+i);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) s[i] &#x3D; s[i-1] + a[i];        memset(dp, 0x3f, sizeof dp); dp[0] &#x3D; 0;        &#x2F;&#x2F;dp[1] &#x3D; s[1] * s[1]; last[1] &#x3D; s[1];        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;            for(int j&#x3D;0; j&lt;i; ++j) &#123;                if(s[i] - s[j] &gt;&#x3D; last[j] and dp[i] &gt; dp[j] + (s[i]-s[j])*(s[i]-s[j])) &#123;                    dp[i] &#x3D; dp[j] + (s[i]-s[j])*(s[i]-s[j]);                     last[i] &#x3D; s[i] - s[j];                &#125;            &#125;        &#125;                printf(&quot;%lld\n&quot;, dp[n]);    &#125;    else printf(&quot;4972194419293431240859891640\n&quot;);        return 0;&#125;</code></pre><h2 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h2><p>$$<br>F(i,j)=<br>\begin{cases}<br>F(i-1,j)&amp; j \leq w_i\<br>\max{F(i-1,j),F(i-1,j-w_i)+v_i}&amp; j &gt; w_i<br>\end{cases}<br>$$</p><p>注意二维转换成一维的时候，$j$ 要<b>从后向前</b>枚举，因为每次的新结果都是根据上一个结果来求得的，从后向前可避免重复取同一物品。</p><h3 id="P2196-挖地雷"><a href="#P2196-挖地雷" class="headerlink" title="P2196 挖地雷"></a>P2196 挖地雷</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N &#x3D; 30;typedef pair &lt;int, vector&lt;int&gt; &gt; piv;vector&lt;int&gt; g[N]; int s1[N], n, w[N], in[N];vector&lt;int&gt; ss[N];piv ans;void outp(vector&lt;int&gt; &amp;ans) &#123;    for(vector&lt;int&gt;::iterator it &#x3D; ans.begin(); it !&#x3D; ans.end(); ++it)         printf(&quot;%d &quot;, *it);    printf(&quot;\n&quot;);&#125;piv dfs(int x, vector&lt;int&gt; s) &#123;    if(s1[x]) &#123;        return (piv)&#123;s1[x], ss[x]&#125;;    &#125;    if(g[x].size() &#x3D;&#x3D; 0) &#123;        s1[x] &#x3D; w[x]; ss[x].clear(); ss[x].push_back(x);        return (piv)&#123;s1[x], ss[x]&#125;;    &#125;    s1[x] &#x3D; w[x];    ss[x].push_back(x);    vector&lt;int&gt; st &#x3D; ss[x];        for(vector&lt;int&gt;::iterator it &#x3D; g[x].begin(); it !&#x3D; g[x].end(); ++it) &#123;        piv p &#x3D; dfs(*it, s);        if(p.first + w[x] &gt; s1[x]) &#123;            s1[x] &#x3D; p.first + w[x];            ss[x] &#x3D; st;            ss[x].insert(ss[x].end(), p.second.begin(), p.second.end());        &#125;    &#125;    return (piv)&#123;s1[x], ss[x]&#125;;&#125;int main() &#123;        scanf(&quot;%d&quot;, &amp;n);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) scanf(&quot;%d&quot;, w+i);    for(int i&#x3D;1, a; i&lt;&#x3D;n; ++i) &#123;        for(int j&#x3D;i+1; j&lt;&#x3D;n; ++j) &#123;            scanf(&quot;%d&quot;, &amp;a);            if(a) g[i].push_back(j), ++in[j];        &#125;    &#125;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        if(!in[i]) &#123;            piv p &#x3D; dfs(i, ss[i]);            if(p.first &gt; ans.first) &#123;                ans.first &#x3D; p.first;                ans.second.clear();                ans.second.insert(ans.second.end(), p.second.begin(), p.second.end());            &#125;        &#125;    &#125;        outp(ans.second);    printf(&quot;%d&quot;, ans.first);        return 0;&#125;</code></pre><h3 id="P1455-搭配购买"><a href="#P1455-搭配购买" class="headerlink" title="P1455 搭配购买"></a>P1455 搭配购买</h3><p>套一个并查集。</p><p>Code：（2019.12.01）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;const int N &#x3D; 11000; struct node &#123;    int c, d;&#125; val[N], tmp[N];int n, m, w, fa[N], list[N], dp[N], t, ans &#x3D; 0;bool flag[N];int root(int x) &#123;    return fa[x] &#x3D;&#x3D; x ? x : fa[x] &#x3D; root(fa[x]);&#125;void operator +&#x3D;(node &amp;A, node B) &#123;    A.c +&#x3D; B.c, A.d +&#x3D; B.d;&#125;int main() &#123;        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;w);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) fa[i] &#x3D; i;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) scanf(&quot;%d%d&quot;, &amp;val[i].c, &amp;val[i].d);        for(int i&#x3D;1; i&lt;&#x3D;m; ++i) &#123;        int u, v;        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        int u1 &#x3D; root(u), v1 &#x3D; root(v);        fa[u1] &#x3D; v1;    &#125;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) root(i);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) tmp[fa[i]] +&#x3D; val[i];        memcpy(list+1, fa+1, n*4);    std::sort(list+1, list+n+1);    t &#x3D; std::unique(list+1, list+n+1) - (list+1);        for(int i&#x3D;1; i&lt;&#x3D;t; ++i)         for(int j&#x3D;w; j&gt;&#x3D;tmp[list[i]].c; --j)             dp[j] &#x3D; std::max(dp[j], dp[j - tmp[list[i]].c] + tmp[list[i]].d);        printf(&quot;%d\n&quot;, dp[w]);        return 0;&#125;</code></pre><h3 id="P1164-小A点菜"><a href="#P1164-小A点菜" class="headerlink" title="P1164 小A点菜"></a>P1164 小A点菜</h3><p><del>这怎么会是橙题啊</del></p><p>注意DP的初值 <code>dp[0] = 1</code>，因为需特别考虑过程中「从0开始买菜」的情况。</p><p>循环中的i 表示已经考虑到了前i道菜。如果能买的起，就直接把 <code>dp[j-a[i]]</code> 转移过来，否则不变。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int dp[11000], n, m, a[110];int main() &#123;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);        dp[0] &#x3D; 1;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        for(int j&#x3D;m; j&gt;&#x3D;a[i]; --j) &#123;            dp[j] +&#x3D; dp[j-a[i]];        &#125;    &#125;        printf(&quot;%d\n&quot;, dp[m]);    return 0;&#125;</code></pre><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>与上面的01背包问题差别不大，只是多了一个条件：每个物品可以取无数次。</p><p>方法很简单，只要 $j$ <b>从前向后</b>枚举即可。这样做其实是变相利用了它的后效性，使同一个物品可以被多次取到。</p><h3 id="P1616-疯狂的采药"><a href="#P1616-疯狂的采药" class="headerlink" title="P1616 疯狂的采药"></a>P1616 疯狂的采药</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int t1, m, dp[int(1e7+10)], t[int(1e4+10)], v[int(1e4+10)];int main() &#123;        scanf(&quot;%d%d&quot;, &amp;t1, &amp;m);    for(int i&#x3D;1; i&lt;&#x3D;m; ++i) scanf(&quot;%d%d&quot;, t+i, v+i);    for(int i&#x3D;1; i&lt;&#x3D;t1; ++i) &#123;        dp[i] &#x3D; dp[i-1];        for(int j&#x3D;1; j&lt;&#x3D;m; ++j)             if(i-t[j]&gt;&#x3D;0) dp[i] &#x3D; max(dp[i], dp[i-t[j]] + v[j]);    &#125;        printf(&quot;%d\n&quot;, dp[t1]);    return 0;&#125;</code></pre><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>转成 01 背包处理</p><p>首先找到最大的 $k$ 使得 $t=\sum_{i=0}^{k}2^i($t &lt; c_i)$，也就是找到最大的小于 $c_i$ 的二的各个次幂和。这样之后，我们就可以通过不重复且有选择地使用 $2^0$到 $2^k$ 来表示出 1到 t所有的数。但是剩下的呢？我们将剩下的 $c_i-t$ 单独分成一个物品，因为 1到 t都可以表示，那么有了这个 $c_i-t$ 物品，就可以表示出所有数了。</p><p>例如，把 $21$ 分为 $[1,2,4,8,6]$，这样就可以从中不重复地选择来表示出 1到 $c_i$ 的所有数了。</p><h3 id="P5020-NOIP-2018-TG-货币系统"><a href="#P5020-NOIP-2018-TG-货币系统" class="headerlink" title="P5020 [NOIP-2018-TG]货币系统"></a>P5020 [NOIP-2018-TG]货币系统</h3><p>感觉是道好题，从部分分一步一步优化就可以推出正解的。乍一看可能以为是个数论，其实并不是。</p><h4 id="80分做法"><a href="#80分做法" class="headerlink" title="80分做法:"></a>80分做法:</h4><p>考虑爆搜，枚举现有系统中的每个数能否被其他已选择的数表示出来。这里可以贪心的想，如果一个数能被另外几个数表示，那么删除它一定是更优解。</p><p><code>dfs()</code> 部分可以换成背包，不过复杂度级别是差不多的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 110;bool us[N];int T, n, maxv, t, a[N];bool dfs(int s, int x, int p) &#123;    if(x &gt; n or s &gt; a[p]) return false;    if(x &#x3D;&#x3D; p or us[x]) return dfs(s, x+1, p);    for(int i&#x3D;0; i&lt;&#x3D;maxv&#x2F;a[x]; ++i) &#123;        if(s+a[x]*i &#x3D;&#x3D; a[p]) return true;        bool f &#x3D; dfs(s+a[x]*i, x+1, p);        if(f) return true;    &#125;    return false;&#125;int main() &#123;        scanf(&quot;%d&quot;, &amp;T);    while(T--) &#123;        scanf(&quot;%d&quot;, &amp;n);                maxv &#x3D; 0;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;            scanf(&quot;%d&quot;, a+i);            maxv &#x3D; max(maxv, a[i]);        &#125;                sort(a+1, a+n+1);        t &#x3D; unique(a+1, a+n+1) - (a+1); int ans &#x3D; t;                memset(us, false, sizeof us);        for(int i&#x3D;1; i&lt;&#x3D;t; ++i) &#123;            if(dfs(0,1,i)) &#123;                us[i] &#x3D; true;                --ans;            &#125;        &#125;                printf(&quot;%d\n&quot;, ans);    &#125;    return 0;&#125;</code></pre><h4 id="满分做法："><a href="#满分做法：" class="headerlink" title="满分做法："></a>满分做法：</h4><p>其实在80分基础上再多想一步就够了：我们不用<b>枚举每个数的表示法</b>来判断可不可以删。直接对所有数dp，如果一个数<b>能用一种以上的方式表示出来</b>，那么就删掉它。显然删掉这个数是无后效的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 110;bool us[N]; int dp[26000];int T, n, maxv, t, a[N];int main() &#123;        scanf(&quot;%d&quot;, &amp;T);    while(T--) &#123;        scanf(&quot;%d&quot;, &amp;n);                maxv &#x3D; 0;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;            scanf(&quot;%d&quot;, a+i);            maxv &#x3D; max(maxv, a[i]);        &#125;                 sort(a+1, a+n+1);        t &#x3D; unique(a+1, a+n+1) - (a+1); int ans &#x3D; t;                memset(dp, 0, sizeof dp);        dp[0] &#x3D; 1;        for(int i&#x3D;1; i&lt;&#x3D;t; ++i) &#123;            for(int j&#x3D;a[i]; j&lt;&#x3D;maxv; ++j) &#123;                dp[j] +&#x3D; dp[j-a[i]];            &#125;        &#125;        for(int i&#x3D;1; i&lt;&#x3D;t; ++i) &#123;            if(dp[a[i]] &gt; 1) --ans;          &#125;                printf(&quot;%d\n&quot;, ans);    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> DP </tag>
            
            <tag> DFS </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly：添加全局吸底 Aplayer 播放器</title>
      <link href="butterfly-aplayer/"/>
      <url>butterfly-aplayer/</url>
      
        <content type="html"><![CDATA[<h1 id="Butterfly：添加全局吸底-Aplayer-播放器"><a href="#Butterfly：添加全局吸底-Aplayer-播放器" class="headerlink" title="Butterfly：添加全局吸底 Aplayer 播放器"></a>Butterfly：添加全局吸底 Aplayer 播放器</h1><div class="note default flat"><p>以下步骤在 Butterfly主题上可以正常生效。如果你使用的是其他主题，可以根据情况自行适配。</p></div><h2 id="配置播放器"><a href="#配置播放器" class="headerlink" title="配置播放器"></a>配置播放器</h2><p>暂时留坑，可以参考<a href="https://demo.jerryc.me/posts/507c070f/">主题文档</a>。</p><h2 id="UI-调整"><a href="#UI-调整" class="headerlink" title="UI 调整"></a>UI 调整</h2><h3 id="调整右下角回到顶部等按钮"><a href="#调整右下角回到顶部等按钮" class="headerlink" title="调整右下角回到顶部等按钮"></a>调整右下角回到顶部等按钮</h3><p>按照上面的步骤设置完成后，浏览器左下角会出现 Aplayer。在手机端浏览博客时，如果展开播放器，会将右下角按钮遮住。</p><p>在Butterfly配置文件中，调整 <code>rightside-bottom</code> 选项：</p><pre class="line-numbers language-Yaml" data-language="Yaml"><code class="language-Yaml"># the position of bottom right button; default unit: px (右下角按鈕距離底部的距離，默認單位為 px)rightside-bottom: 80px</code></pre><h3 id="调整-TOC-目录按钮"><a href="#调整-TOC-目录按钮" class="headerlink" title="调整 TOC 目录按钮"></a>调整 TOC 目录按钮</h3><p>打开文章页面时，你会发现打开 Toc 目录的按钮被遮挡了。我们需要修改 CSS 来改变按钮的位置。</p><p>请在主题配置文件中，将这段代码添加到 inject 去：</p><pre class="line-numbers language-Yaml" data-language="Yaml"><code class="language-Yaml">inject:  head:    - &#39;&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;#toggle-sidebar &#123;bottom: 80px&#125;&lt;&#x2F;style&gt;&#39;</code></pre><h3 id="调整-Aplayer-收回方式"><a href="#调整-Aplayer-收回方式" class="headerlink" title="调整 Aplayer 收回方式"></a>调整 Aplayer 收回方式</h3><p>如果你觉得Aplayer占地太大，影响正常阅读，可以设置Aplayer收回时将音乐Cover也隐藏掉，只留下右侧的箭头栏，效果如本博客（手机端浏览）所示。</p><p>请在主题配置文件中，将这段代码添加到 inject 去：</p><pre class="line-numbers language-Yaml" data-language="Yaml"><code class="language-Yaml">inject:  head:    - &#39;&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body&#123;left:-66px!important&#125;.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover&#123;left:0!important&#125;&lt;&#x2F;style&gt;&#39;</code></pre><h3 id="调整-APlayer-歌词显示"><a href="#调整-APlayer-歌词显示" class="headerlink" title="调整 APlayer 歌词显示"></a>调整 APlayer 歌词显示</h3><p>Aplayer的歌词默认在底部正中显示，也会遮挡一些内容，比如index页面下方的小三角。当然我们可以通过调整三角高度的方式解决，但是如果可以设置歌词默认不显示，效果可能会更好。</p><p>修改Butterfly配置文件中的 <code>CDN.meting_js</code> 配置，将CDN链接替换即可。</p><pre class="line-numbers language-Diff" data-language="Diff"><code class="language-Diff">CDN:  ...  # aplayer  aplayer_css: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;aplayer&#x2F;dist&#x2F;APlayer.min.css  aplayer_js: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;aplayer&#x2F;dist&#x2F;APlayer.min.js- meting_js: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;metowolf&#x2F;MetingJS@1.2&#x2F;dist&#x2F;Meting.min.js+ meting_js: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;SerokSSR&#x2F;cdn&#x2F;meting.min.js</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
            <tag> Aplayer </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL：SET &amp; MULTISET</title>
      <link href="stl-set/"/>
      <url>stl-set/</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL：SET-amp-MULTISET"><a href="#C-STL：SET-amp-MULTISET" class="headerlink" title="C++ STL：SET &amp; MULTISET"></a>C++ STL：SET &amp; MULTISET</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><table><thead><tr><th>方式</th><th>效果</th></tr></thead><tbody><tr><td><code>set &lt;数据类型名&gt; 集合名;</code></td><td>先定义一个容器，容器内无任何元素</td></tr><tr><td><code>set &lt;数据类型名&gt; 集合名(另一个集合名);</code></td><td>定义一个集合并用另一个集合初始化（只能是数据类型相同的集合，不能是数组）</td></tr><tr><td><code>set &lt;数据类型名&gt; 集合名(另一个集合名.begin(), 另一个集合名.end());</code></td><td>定义一个集合并用另一个集合初始化（只能是数据类型相同的集合，不能是数组）</td></tr><tr><td><code>set &lt;数据类型名&gt; 集合名[集合数量];</code></td><td>定义集合数组</td></tr><tr><td><code>set &lt;Elem&gt;</code></td><td>产生一个set，以 (operator &lt;) 为排序准则</td></tr><tr><td><code>set &lt;Elem, cmp&gt;</code></td><td>产生一个set，以cmp为排序准则</td></tr></tbody></table><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="非变动性操作"><a href="#非变动性操作" class="headerlink" title="非变动性操作"></a>非变动性操作</h3><table><thead><tr><th align="center">操作</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">c.size()</td><td align="center">返回当前的元素数量</td></tr><tr><td align="center">c.empty ()</td><td align="center">判断set是否为空，等同于 c.size() == 0，效率更高</td></tr><tr><td align="center">c.max_size()</td><td align="center">返回能容纳的元素最大数量</td></tr><tr><td align="center">c1 == c2</td><td align="center">判断c1是否等于c2</td></tr></tbody></table><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>set和multiset都是平衡树，$O(\log n)$ 级别查找。</p><table><thead><tr><th align="center">操作</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">count(elem)</td><td align="center">返回元素值为elem的个数</td></tr><tr><td align="center">find(elem)</td><td align="center">返回元素值为elem的第一个元素，如果没有返回end()</td></tr><tr><td align="center">lower_bound(elem)</td><td align="center">返回元素值为elem的第一个可安插位置，也就是元素值 &gt;= elem的第一个元素位置</td></tr><tr><td align="center">upper_bound(elem)</td><td align="center">返回元素值为elem的最后一个可安插位置，也就是元素值 &gt; elem 的第一个元素位置</td></tr><tr><td align="center">equal_range(elem)</td><td align="center">返回elem可安插的第一个位置和最后一个位置，也就是元素值 == elem的区间</td></tr></tbody></table><h3 id="赋值与迭代"><a href="#赋值与迭代" class="headerlink" title="赋值与迭代"></a>赋值与迭代</h3><p>sets和multisets的迭代器是双向迭代器，对迭代器操作而言，所有的元素都被视为常数，可以确保你不会人为改变元素值，从而打乱既定顺序，所以无法调用变动性算法，如 <code>remove()</code>。</p><table><thead><tr><th align="center">操作</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">c1 = c2</td><td align="center">将c2的元素全部给c1</td></tr><tr><td align="center">c1.swap(c2)</td><td align="center">将c1和c2 的元素互换</td></tr><tr><td align="center">swap(c1, c2)</td><td align="center">同上，全局函数</td></tr><tr><td align="center">c.begin()</td><td align="center">略</td></tr><tr><td align="center">c.end()</td><td align="center">略</td></tr><tr><td align="center">c.rbegin()</td><td align="center">略</td></tr><tr><td align="center">c.rend()</td><td align="center">略</td></tr></tbody></table><h3 id="安插和删除元素"><a href="#安插和删除元素" class="headerlink" title="安插和删除元素"></a>安插和删除元素</h3><p>必须保证参数有效，迭代器必须指向有效位置，序列起点不能位于终点之后，不能从空容器删除元素。</p><table><thead><tr><th align="center">操作</th><th align="center">返回值</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">c.insert(elem)</td><td align="center"><code>pair &lt;iterator, bool&gt;</code></td><td align="center">插入一个elem副本</td></tr><tr><td align="center">c.insert(pos, elem)</td><td align="center"><code>iterator</code></td><td align="center">安插一个elem元素副本，返回元素的迭代器。pos为搜索起点，提升插入速度。</td></tr><tr><td align="center">c.insert(beg,end)</td><td align="center"><code>void</code></td><td align="center">将区间[beg,end)所有的元素安插到c。</td></tr><tr><td align="center">c.erase(elem)</td><td align="center">无符号整数</td><td align="center">删除与elem相等的所有元素，返回被移除的元素个数。</td></tr><tr><td align="center">c.erase(pos)</td><td align="center"><code>void</code></td><td align="center">移除迭代器pos所指位置元素。</td></tr><tr><td align="center">c.erase(beg,end)</td><td align="center"><code>void</code></td><td align="center">移除区间[beg,end)所有元素，返回 <code>void</code>。</td></tr><tr><td align="center">c.clear()</td><td align="center"><code>void</code></td><td align="center">移除所有元素，将容器清空</td></tr></tbody></table><h2 id="set与multiset的异同"><a href="#set与multiset的异同" class="headerlink" title="set与multiset的异同"></a>set与multiset的异同</h2><ul><li><code>set::insert(key)</code> 的返回值是一个 <code>pair&lt;iterator, bool&gt;</code>，其中pair中的bool成员表明了key被插入之前，set中是否已存在相同的key。如果set中已经存在相同key的元素，那么插入操作是会失败的，新的元素不会被插进去。而 <code>multiset::insert(key)</code> 的返回值只是一个iterator，插入操作总是会成功的。</li><li><code>multiset::count(key)</code> 的返回值可能大于1。</li><li><code>multiset::size()</code> 的返回值是multiset中元素的个数，而不是值的个数。比如，{1, 1, 2}的size是3，而不是2。</li><li><code>multiset::erase(key)</code> 会将对应的key全部删掉，所以对{1, 1, 2}调用 <code>erase(1)</code> 之后，它就变成了{2}。</li><li>只要key存在于集合中，<code>set::equal_range(key)</code> 的返回值 <code>pair&lt;iterator1, iterator2&gt;</code> 总是会有 <code>++iterator1 == iterator2</code>。但是对multiset来说就不一定了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> STL </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo：将你的博客部署到 Vercel</title>
      <link href="hexo-vercel/"/>
      <url>hexo-vercel/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo：将你的博客部署到-Vercel"><a href="#Hexo：将你的博客部署到-Vercel" class="headerlink" title="Hexo：将你的博客部署到 Vercel"></a>Hexo：将你的博客部署到 Vercel</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>近些日子，静态网站的热度又渐渐高了起来。相比于动态网站，静态网站具有轻量、无需服务器、利于SEO、速度快等特点，非常适合个人博客。再加上Hexo、Hugo等静态博客渲染框架的日渐成熟，已能与Wordpress、Typecho等老牌动态博客框架分庭抗礼。</p><p>与此同时，很多静态托管网站也应运而生。各种托管网站看似鱼龙混杂，其实由于各种原因，在国内能用的也就那么几家；如果你像我一样，没有服务器、没有备案，还想白嫖（穷），那么仅有的选择就更少了。综合各种因素，目前最适合托管静态博客的服务有：</p><h3 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h3><p>微软旗下，闻名遐迩的全球第一大开源仓库网站。服务器设在荷兰、美国等地，近期由于一些原因，部分地区部分运营商的用户遭到<a href="https://www.baidu.com/s?ie=UTF-8&wd=dns%E6%B1%A1%E6%9F%93">DNS污染</a>，无法正常访问。</p><h3 id="Gitee-Pages"><a href="#Gitee-Pages" class="headerlink" title="Gitee Pages"></a>Gitee Pages</h3><p>OSCHINA旗下，服务器在上海腾讯云，速度较快，较稳定，提供 <code>xxx.gitee.io</code> 域名，不支持免费自定义域名。</p><h3 id="Coding-Pages"><a href="#Coding-Pages" class="headerlink" title="Coding Pages"></a>Coding Pages</h3><p>腾讯旗下，服务器在香港/新加坡腾讯云，速度尚可，但稳定性差。部分地区速度极慢，一些地区的CMCC宽带甚至不能访问。支持免费自定义域名。</p><h3 id="Vercel"><a href="#Vercel" class="headerlink" title="Vercel"></a>Vercel</h3><p>原名Zeit，服务器在美国，在港台有CDN节点。速度略慢于Coding，但大部分地区均可正常访问，不过晚上速度会慢一些。提供自定义 <code>xxx.now.sh</code> 和 <code>xxx.vercel.app</code> 域名，且支持免费绑定个人域名。</p><p>大部分网站采用的一般都是GitHub + Coding双部署的形式。这种方法比较麻烦，需要DNSPod解析，因此需要实名认证，而且还真未必快到那里去。</p><p>Colsrch大佬出过一篇三部署教程，使用了Coding（联通线路），Vercel（默认线路），Cloudflare回源GitHub Page（移动线路），速度略有提升，但是门槛较高，对小白并不友好。而且近期Coding似乎越来越不稳定了，所以也不太推荐此方法。</p><p>下面是晚上六点左右，Vercel与Gitee的速度对比。和99块钱相比，慢点就慢点吧（</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/images/2020/08/09/2509c2179b5ace2e1ea85ec83cebefc5.png"></p><p>还是由于某种原因，市面上的Vercel部署教程并不多。而且由于Vercel里的一些操作还是挺不常规的，所以就写了这么一篇文章，说一下将网站部署在 Vercel的详细过程。</p><h2 id="导入-GitHub-仓库"><a href="#导入-GitHub-仓库" class="headerlink" title="导入 GitHub 仓库"></a>导入 GitHub 仓库</h2><p>Vercel是一个静态网页部署网站，并不托管代码。因此，我们通过GitHub来托管 <code>hexo deploy</code> 生成的网页文件，并设置自动导入。当你的源代码仓库有变动后，Vercel会第一时间检测到并重新部署网站，部署完成后会通过邮件提醒。</p><div class="note default flat"><p>在开始之前，请准备一个 GitHub账号（注意不能是绑有QQ邮箱的）、一个Git仓库（存储Hexo生成的页面）。</p></div><p>进入<a href="https://vercel.com/signup">Vercel官网</a>，点击 <code>Continue with GitHub</code></p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/images/2020/08/09/01811ea1c3f3db90b649b0704d235c84.png"></p><p><b>注意：如果出现下图所示的情况，请确认你的GitHub账号上没有绑QQ邮箱（即便它不是主邮箱）。如果仍然报错，请换用国外邮箱。</b></p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/images/2020/08/16/7c0f7cf536cf325d31120dea1c745a5d.png"></p><p>授权完成后，选择 <code>Import Git Repository</code>，点击Continue，进入如下界面。输入你的仓库 url（https）。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/laugh0608/CDN/img/20200809110421.png"></p><div class="note default flat"><p>如果你配置过 GitHub Pages，那么这个地方直接填入你的 GitHub Pages仓库就可以了。</p><p>注意：<b>你生成的页面应推送至 master 分支，而不是 gh-pages 分支。</b>如果你之前设置了多部署，比如：</p><pre class="line-numbers language-Yaml" data-language="Yaml"><code class="language-Yaml">deploy:  type: git  repo:    github: xxx    coding: xxx  branch: master</code></pre><p><b>请务必将 GitHub 拆出来单独写</b>，就像这样：</p><pre class="line-numbers language-Yaml" data-language="Yaml"><code class="language-Yaml">deploy:- type: git  repo:    coding: xxx- type: git  repo: git@github.com:xxx&#x2F;xxx.git  branch: master</code></pre><p>因为如果按照第一种方式，<b>你的生成页面有一定概率会被推送至 gh-pages 分支（由于 Hexo 的默认设置）</b>，导致Vercel无法拉取。</p></div><p>导入项目中会弹出一些自定义选项，<b>不知道会出什么锅的话就不要改</b>，顺着右下角的蓝色键一直点，遵照默认选项就可以了。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/images/2020/08/09/73af45de20ef01e1f34bd7bbf03faece.png"></p><p>这里建议选择 <code>All repo</code>，方便后续部署。</p><p>部署完成后，Vercel会提供几个默认域名，可以通过 <code>[项目名].[用户名].vercel.app</code> 访问。</p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>进入 dashboard，点击[项目卡片] -&gt; View Domains</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/images/2020/08/09/efb29bee08b2ef23e0ec2d35cf0c53c8.png"></p><p>如果你想使用Vercel提供的二级域名，直接添加 <code>xxx.now.sh</code>（或 <code>xxx.vercel.app</code>，看你想要哪个），如果无人占用，会自动验证成功。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/images/2020/08/09/0998d5c3f1a7cd469dde50ac6080d3ff.png"></p><p>如果你想绑定自己的域名，也是在输入框中输入你想要绑定的网址，点击右侧 Add即可。下方会提示Invalid Config，并给出两种绑定方式（A/CNAME + NS），但是不要听他的，而是请按照下面的方式：</p><h3 id="验证方式"><a href="#验证方式" class="headerlink" title="验证方式"></a>验证方式</h3><ul><li>如果是根域名，请在你的DNS解析处添加 A记录，指向 <code>76.76.21.21</code></li><li>如果是子域名，请在你的DNS解析处添加CNAME记录，指向 <code>cname.vercel-dns.com</code></li></ul><p>添加记录后等待片刻再刷新，下面显示两个对号即表明验证成功。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/images/2020/08/09/45a7ed60c7ee4d172b406f1919c5fa1b.png"></p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>如果你绑定了多个域名，可以点击域名卡片右上角的 Edit，将某个域名重定向至你的其他域名。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>至此Vercel的部署过程就结束了。</p><div class="note warning flat"><p>初次部署后再进入dashboard，可能会偶尔出现配置好的域名显示invalid config的现象，尽管DNS解析是正常的。经博主测试，此状态下网页仍能正常访问（已排除DNS缓存的问题），可能是Vercel面板的bug吧。</p></div><p>如果你在部署过程中有什么问题，可以可以在下方留言，或者直接向 <a href="mailto:&#x73;&#117;&#112;&#x70;&#111;&#x72;&#116;&#x40;&#x76;&#101;&#114;&#99;&#x65;&#108;&#x2e;&#99;&#111;&#x6d;">&#x73;&#117;&#112;&#x70;&#111;&#x72;&#116;&#x40;&#x76;&#101;&#114;&#99;&#x65;&#108;&#x2e;&#99;&#111;&#x6d;</a> 发邮件，能不能用中文我没试过。免费用户一般回复时间不早于 48h ，不晚于 96h。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 部署 </tag>
            
            <tag> Vercel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo：为你的博客配置 PWA</title>
      <link href="hexo-gulp-pwa/"/>
      <url>hexo-gulp-pwa/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo：使用-Gulp-为你的博客配置-PWA"><a href="#Hexo：使用-Gulp-为你的博客配置-PWA" class="headerlink" title="Hexo：使用 Gulp 为你的博客配置 PWA"></a>Hexo：使用 Gulp 为你的博客配置 PWA</h1><div class="note default flat"><p>使用这个方法之前，请先卸载掉其它的 PWA 插件，并安装 Gulp 和 WorkBox。</p></div><pre class="line-numbers language-Powershell" data-language="Powershell"><code class="language-Powershell">npm install gulp-cli -gnpm install workbox-build gulp --save-dev</code></pre><p>本文参考<a href="https://io-oi.me/tech/pwa-via-workbox/">利用 Workbox 实现博客的 PWA</a>和<a href="https://demo.jerryc.me/posts/4073eda/">Butterfly进阶教程</a>。</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>渐进式网络应用程式（英语：Progressive Web Apps，简称：PWA）是一种普通网页或网站架构起来的网络应用程式，但它可以以传统应用程式或原生移动应用程式形式展示给用户。这种应用程式形态视图将目前最为现代化的浏览器提供的功能与行动装置的体验优势相结合。</p><p>当你的网站实现了 PWA，那就代表了</p><ul><li>用户可以添加你的博客到电脑/手机的桌面，以原生应用般的方式浏览你的博客</li><li>用户本地可以自动生成缓存，二次访问速度大大加快</li><li>用户可以离线浏览你的博客</li></ul><p>下面的 PWA实现方法借助了 Gulp插件，在站点有内容更新时，可以弹窗提醒用户刷新页面。</p><h2 id="开启主题相关设置"><a href="#开启主题相关设置" class="headerlink" title="开启主题相关设置"></a>开启主题相关设置</h2><p>以 Butterfly 主题为例，在 <code>butterfly.yml</code> 中开启 PWA 选项</p><p>实例：</p><pre class="line-numbers language-Yaml" data-language="Yaml"><code class="language-Yaml">pwa:  enable: true  manifest: &#x2F;manifest.json # 清单文件，下文将介绍如何生成  theme_color: &quot;#fff&quot; # 应用程序顶栏的背景色  apple_touch_icon: &#x2F;img&#x2F;pwa&#x2F;apple-touch-icon.png # 添加至苹果移动设备的主屏幕后显示的图标，尽量使用 png 格式  favicon_32_32: &#x2F;img&#x2F;pwa&#x2F;32.png # 32 * 32 像素，网页图标  favicon_16_16: &#x2F;img&#x2F;pwa&#x2F;16.png # 16 * 16 像素，网页图标  mask_icon: &#x2F;img&#x2F;pwa&#x2F;safari-pinned-tab.svg # 苹果电脑 Touch Bar 区域显示的收藏栏封面图，须使用 svg 格式</code></pre><p><strong>图片尺寸要求：</strong></p><ul><li>apple_touch_icon：192 * 192 像素</li><li>mask_icon：viewBox的值必须是 0 0 16 16</li></ul><p>如果你的主题没有内置PWA，下面附有Butterfly主题的PWA部分，可以根据你所用的主题调整下面的Pug模板，编译后插入到html生成模板的head处。</p><pre class="line-numbers language-Pug" data-language="Pug"><code class="language-Pug">link(rel&#x3D;&quot;manifest&quot; href&#x3D;url_for(theme.pwa.manifest))if(theme.pwa.theme_color)   meta(name&#x3D;&quot;theme-color&quot; content&#x3D;theme.pwa.theme_color)if(theme.pwa.theme_color)   meta(name&#x3D;&quot;msapplication-TileColor&quot; content&#x3D;theme.pwa.theme_color)if(theme.pwa.apple_touch_icon)   link(rel&#x3D;&quot;apple-touch-icon&quot; sizes&#x3D;&quot;180x180&quot; href&#x3D;url_for(theme.pwa.apple_touch_icon))if(theme.pwa.favicon_32_32)   link(rel&#x3D;&quot;icon&quot; type&#x3D;&quot;image&#x2F;png&quot; sizes&#x3D;&quot;32x32&quot; href&#x3D;url_for(theme.pwa.favicon_32_32))if(theme.pwa.favicon_16_16)  link(rel&#x3D;&quot;icon&quot; type&#x3D;&quot;image&#x2F;png&quot; sizes&#x3D;&quot;16x16&quot; href&#x3D;url_for(theme.pwa.favicon_16_16))if(theme.pwa.mask_icon)  link(rel&#x3D;&quot;mask-icon&quot; href&#x3D;url_for(theme.pwa.mask_icon) color&#x3D;&quot;#5bbad5&quot;)</code></pre><h2 id="配置-manifest-json"><a href="#配置-manifest-json" class="headerlink" title="配置 manifest.json"></a>配置 <code>manifest.json</code></h2><p>创建 <code>manifest.json</code>，路径应与配置文件中所填路径相同。</p><p><b>实例及配置说明：</b></p><pre class="line-numbers language-Json" data-language="Json"><code class="language-Json">&#123;  &quot;name&quot;: &quot;Serok&#39;s Blog&quot;, &#x2F;&#x2F; 应用全称  &quot;short_name&quot;: &quot;Seeker&quot;, &#x2F;&#x2F; 应用简称  &quot;theme_color&quot;: &quot;#49b1f5&quot;, &#x2F;&#x2F; 应用主题色  &quot;background_color&quot;: &quot;#49b1f5&quot;, &#x2F;&#x2F; 加载应用时的背景色  &quot;display&quot;: &quot;minimal-ui&quot;, &#x2F;&#x2F; 首選顯示模式  &#x2F;&#x2F;更多顯示模式：&quot;fullscreen&quot;, &quot;standalone&quot;, &quot;browser&quot;  &quot;scope&quot;: &quot;&#x2F;&quot;,  &quot;start_url&quot;: &quot;&#x2F;&quot;,  &quot;icons&quot;: [     &#x2F;&#x2F; 指定 icons 參數，用來適配不同設備    &#x2F;&#x2F; 需為 png 格式，至少包含一个 192 * 192 像素的圖標    &#123;       &quot;src&quot;: &quot;https:&#x2F;&#x2F;snow.js.org&#x2F;image&#x2F;pwaicons&#x2F;192.png&quot;, &#x2F;&#x2F; 建议采用绝对路径      &quot;sizes&quot;: &quot;192x192&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;  ],  &quot;splash_pages&quot;: null &#x2F;&#x2F; 自定義启动动画&#125;</code></pre><div class="note default flat"><p>Hexo采用的是严格 Json规范，因此 <code>manifest.json</code> 文件配置好后，需删除文件中的所有注释。</p></div><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在命令行中输入</p><pre class="line-numbers language-Powershell" data-language="Powershell"><code class="language-Powershell">npm install workbox-build gulp --save-dev</code></pre><h2 id="创建-gulpfile-js-文件"><a href="#创建-gulpfile-js-文件" class="headerlink" title="创建 gulpfile.js 文件"></a>创建 <code>gulpfile.js</code> 文件</h2><p>在博客的根目录下，创建一个 <code>gulpfile.js</code> 文件</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const gulp &#x3D; require(&quot;gulp&quot;);const workbox &#x3D; require(&quot;workbox-build&quot;);gulp.task(&#39;generate-service-worker&#39;, () &#x3D;&gt; &#123;    return workbox.injectManifest(&#123;        swSrc: &#39;.&#x2F;sw-template.js&#39;,        swDest: &#39;.&#x2F;public&#x2F;sw.js&#39;,        globDirectory: &#39;.&#x2F;public&#39;,        globPatterns: [            &quot;**&#x2F;*.&#123;html,css,js,json,woff2&#125;&quot;        ],        modifyURLPrefix: &#123;            &quot;&quot;: &quot;.&#x2F;&quot;        &#125;    &#125;);&#125;);gulp.task(&quot;build&quot;, gulp.series(&quot;generate-service-worker&quot;));</code></pre><h2 id="创建-sw-template-js-文件"><a href="#创建-sw-template-js-文件" class="headerlink" title="创建 sw-template.js 文件"></a>创建 <code>sw-template.js</code> 文件</h2><p>在博客的根目录下，创建一个 <code>sw-template.js</code> 文件</p><pre class="line-numbers language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">const workboxVersion &#x3D; &#39;5.1.3&#39;;importScripts(&#96;https:&#x2F;&#x2F;storage.googleapis.com&#x2F;workbox-cdn&#x2F;releases&#x2F;$&#123;workboxVersion&#125;&#x2F;workbox-sw.js&#96;);workbox.core.setCacheNameDetails(&#123;    prefix: &quot;Serok&#39;s Blog&quot;&#125;);workbox.core.skipWaiting();workbox.core.clientsClaim();workbox.precaching.precacheAndRoute(self.__WB_MANIFEST,&#123;    directoryIndex: null&#125;);workbox.precaching.cleanupOutdatedCaches();&#x2F;&#x2F; Imagesworkbox.routing.registerRoute(    &#x2F;\.(?:png|jpg|jpeg|gif|bmp|webp|svg|ico)$&#x2F;,    new workbox.strategies.CacheFirst(&#123;        cacheName: &quot;images&quot;,        plugins: [            new workbox.expiration.ExpirationPlugin(&#123;                maxEntries: 1000,                maxAgeSeconds: 60 * 60 * 24 * 30            &#125;),            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;                statuses: [0, 200]            &#125;)        ]    &#125;));&#x2F;&#x2F; Fontsworkbox.routing.registerRoute(    &#x2F;\.(?:eot|ttf|woff|woff2)$&#x2F;,    new workbox.strategies.CacheFirst(&#123;        cacheName: &quot;fonts&quot;,        plugins: [            new workbox.expiration.ExpirationPlugin(&#123;                maxEntries: 1000,                maxAgeSeconds: 60 * 60 * 24 * 30            &#125;),            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;                statuses: [0, 200]            &#125;)        ]    &#125;));&#x2F;&#x2F; Google Fontsworkbox.routing.registerRoute(    &#x2F;^https:\&#x2F;\&#x2F;fonts\.googleapis\.com&#x2F;,    new workbox.strategies.StaleWhileRevalidate(&#123;        cacheName: &quot;google-fonts-stylesheets&quot;    &#125;));workbox.routing.registerRoute(    &#x2F;^https:\&#x2F;\&#x2F;fonts\.gstatic\.com&#x2F;,    new workbox.strategies.CacheFirst(&#123;        cacheName: &#39;google-fonts-webfonts&#39;,        plugins: [            new workbox.expiration.ExpirationPlugin(&#123;                maxEntries: 1000,                maxAgeSeconds: 60 * 60 * 24 * 30            &#125;),            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;                statuses: [0, 200]            &#125;)        ]    &#125;));&#x2F;&#x2F; Static Librariesworkbox.routing.registerRoute(    &#x2F;^https:\&#x2F;\&#x2F;cdn\.jsdelivr\.net&#x2F;,    new workbox.strategies.CacheFirst(&#123;        cacheName: &quot;static-libs&quot;,        plugins: [            new workbox.expiration.ExpirationPlugin(&#123;                maxEntries: 1000,                maxAgeSeconds: 60 * 60 * 24 * 30            &#125;),            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;                statuses: [0, 200]            &#125;)        ]    &#125;));workbox.googleAnalytics.initialize();</code></pre><p><b>注意：把 prefix 修改为你博客的名字（最好用英文）。</b></p><p>上面的文件涵盖了大多数资源的缓存策略。如果你想缓存其他类型的资源（例如一些国内的镜像 CDN 库），或者想使用其他的缓存方式，请自行<a href="https://developers.google.com/web/tools/workbox/modules/workbox-strategies">查看相关文档</a>并添加。</p><h2 id="添加-js-进主题"><a href="#添加-js-进主题" class="headerlink" title="添加 js 进主题"></a>添加 js 进主题</h2><p>配置 <code>butterfly.yml</code>, 添加需要的 css 和 js</p><pre class="line-numbers language-Yaml" data-language="Yaml"><code class="language-Yaml">inject:  head:    - &#39;&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;.app-refresh&#123;position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease&#125;.app-refresh-wrap&#123;display:flex;color:#fff;height:100%;align-items:center;justify-content:center&#125;.app-refresh-wrap a&#123;color:#fff;text-decoration:underline;cursor:pointer&#125;&lt;&#x2F;style&gt;&#39;  bottom:    - &#39;&lt;div class&#x3D;&quot;app-refresh&quot; id&#x3D;&quot;app-refresh&quot;&gt; &lt;div class&#x3D;&quot;app-refresh-wrap&quot;&gt; &lt;label&gt;✨ 网站已更新最新版本 👉&lt;&#x2F;label&gt; &lt;a href&#x3D;&quot;javascript:void(0)&quot; onclick&#x3D;&quot;location.reload()&quot;&gt;点击刷新&lt;&#x2F;a&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script&gt;function showNotification()&#123;if(GLOBAL_CONFIG.Snackbar)&#123;var t&#x3D;&quot;light&quot;&#x3D;&#x3D;&#x3D;document.documentElement.getAttribute(&quot;data-theme&quot;)?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e&#x3D;GLOBAL_CONFIG.Snackbar.position;Snackbar.show(&#123;text:&quot;已更新最新版本&quot;,backgroundColor:t,duration:5e5,pos:e,actionText:&quot;点击刷新&quot;,actionTextColor:&quot;#fff&quot;,onActionClick:function(t)&#123;location.reload()&#125;&#125;)&#125;else&#123;var o&#x3D;&#96;top: 0; background: $&#123;&quot;light&quot;&#x3D;&#x3D;&#x3D;document.documentElement.getAttribute(&quot;data-theme&quot;)?&quot;#49b1f5&quot;:&quot;#1f1f1f&quot;&#125;;&#96;;document.getElementById(&quot;app-refresh&quot;).style.cssText&#x3D;o&#125;&#125;&quot;serviceWorker&quot;in navigator&amp;&amp;(navigator.serviceWorker.controller&amp;&amp;navigator.serviceWorker.addEventListener(&quot;controllerchange&quot;,function()&#123;showNotification()&#125;),window.addEventListener(&quot;load&quot;,function()&#123;navigator.serviceWorker.register(&quot;&#x2F;sw.js&quot;)&#125;));&lt;&#x2F;script&gt;&#39;</code></pre><p>同样，如果你使用的不是Butterfly主题，可以在所示代码的基础上修改以适配你的主题。以下是展开后的代码，便于修改调试。</p><h3 id="以下代码请插入到头部-lt-head-gt-之前："><a href="#以下代码请插入到头部-lt-head-gt-之前：" class="headerlink" title="以下代码请插入到头部 &lt;/head&gt; 之前："></a>以下代码请插入到头部 <code>&lt;/head&gt;</code> 之前：</h3><pre class="line-numbers language-Html" data-language="Html"><code class="language-Html">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;  .app-refresh &#123;    position: fixed;    top: -2.2rem;    left: 0;    right: 0;    z-index: 99999;    padding: 0 1rem;    font-size: 15px;    height: 2.2rem;    transition: all 0.3s ease;  &#125;  .app-refresh-wrap &#123;    display: flex;    color: #fff;    height: 100%;    align-items: center;    justify-content: center;  &#125;  .app-refresh-wrap span &#123;    color: #fff;    text-decoration: underline;    cursor: pointer;  &#125;&lt;&#x2F;style&gt;</code></pre><h3 id="以下代码请插入到底部-lt-body-gt-之前："><a href="#以下代码请插入到底部-lt-body-gt-之前：" class="headerlink" title="以下代码请插入到底部 &lt;/body&gt; 之前："></a>以下代码请插入到底部 <code>&lt;/body&gt;</code> 之前：</h3><pre class="line-numbers language-Html" data-language="Html"><code class="language-Html">&lt;div class&#x3D;&quot;app-refresh&quot; id&#x3D;&quot;app-refresh&quot;&gt;  &lt;div class&#x3D;&quot;app-refresh-wrap&quot;&gt;    &lt;label&gt;✨ 网站已更新最新版本 👉&lt;&#x2F;label&gt;    &lt;a href&#x3D;&quot;javascript:void(0)&quot; onclick&#x3D;&quot;location.reload()&quot;&gt;点击刷新&lt;&#x2F;a&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script&gt;  if (&#39;serviceWorker&#39; in navigator) &#123;    if (navigator.serviceWorker.controller) &#123;      navigator.serviceWorker.addEventListener(&#39;controllerchange&#39;, function () &#123;        showNotification()      &#125;)    &#125;    window.addEventListener(&#39;load&#39;, function () &#123;      navigator.serviceWorker.register(&#39;&#x2F;sw.js&#39;)    &#125;)  &#125;  function showNotification() &#123;    if (GLOBAL_CONFIG.Snackbar) &#123;      var snackbarBg &#x3D;        document.documentElement.getAttribute(&#39;data-theme&#39;) &#x3D;&#x3D;&#x3D; &#39;light&#39;          ? GLOBAL_CONFIG.Snackbar.bgLight          : GLOBAL_CONFIG.Snackbar.bgDark      var snackbarPos &#x3D; GLOBAL_CONFIG.Snackbar.position      Snackbar.show(&#123;        text: &#39;已更新最新版本&#39;,        backgroundColor: snackbarBg,        duration: 500000,        pos: snackbarPos,        actionText: &#39;点击刷新&#39;,        actionTextColor: &#39;#fff&#39;,        onActionClick: function (e) &#123;          location.reload()        &#125;,      &#125;)    &#125; else &#123;      var showBg &#x3D;        document.documentElement.getAttribute(&#39;data-theme&#39;) &#x3D;&#x3D;&#x3D; &#39;light&#39;          ? &#39;#49b1f5&#39;          : &#39;#1f1f1f&#39;      var cssText &#x3D; &#96;top: 0; background: $&#123;showBg&#125;;&#96;      document.getElementById(&#39;app-refresh&#39;).style.cssText &#x3D; cssText    &#125;  &#125;&lt;&#x2F;script&gt;</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>为了方便每次部署，可以在你的博客根目录下新建 <code>deploy.sh</code>，添加以下内容：</p><pre class="line-numbers language-Bash" data-language="Bash"><code class="language-Bash">#!&#x2F;bin&#x2F;bashecho &quot;Start&quot;hexo cleanhexo generategulphexo deployecho &quot;Finish&quot;echo 按任意键继续read -n 1</code></pre><p>然后每次部署就可以直接运行这个脚本了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> Gulp </tag>
            
            <tag> PWA </tag>
            
            <tag> 应用程序 </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普及组算法：简单数论 &amp; 并查集</title>
      <link href="num-theory/"/>
      <url>num-theory/</url>
      
        <content type="html"><![CDATA[<h1 id="简单数论"><a href="#简单数论" class="headerlink" title="简单数论"></a>简单数论</h1><p>一点都不简单</p><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><p>又称辗转相除法<br>迭代求两数 gcd 的做法<br>由 $(a, b) = (a, ka + b)$ 的性质：$\gcd(a, b) = \gcd(b, a\bmod b)$<br>容易证明这么做的复杂度是 $O(\log n)$</p><p>注意：$\gcd(0, a) = a$</p><h2 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h2><p>设(a, b) = d，则对任意整数x, y，有d|(ax + by) 成立；<br>特别地，一定存在x, y 满足ax + by = d<br>等价的表述：不定方程ax + by = c(a, b, c 为整数) 有解的充要条件为(a, b)|c<br>推论：a, b 互质等价于ax + by = 1 有解</p><h3 id="P4549-【模板】裴蜀定理"><a href="#P4549-【模板】裴蜀定理" class="headerlink" title="P4549 【模板】裴蜀定理"></a>P4549 【模板】裴蜀定理</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;        int n; scanf(&quot;%d&quot;, &amp;n); int a; scanf(&quot;%d&quot;, &amp;a); int g &#x3D; a;     for(int i&#x3D;2; i&lt;&#x3D;n; ++i) &#123;        scanf(&quot;%d&quot;, &amp;a); if(a &#x3D;&#x3D; 0) continue;        if(a &lt; 0) a &#x3D; -a;        g &#x3D; __gcd(g, a);    &#125;    printf(&quot;%d\n&quot;, g);    return 0;&#125;</code></pre><h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><p>考虑如何求得ax + by = d 的一个解。这里d = (a, b)<br>考虑使用欧几里德算法的思想，令a = bq + r，其中r = a mod b；<br>递归求出bx + ry = d 的一个解。<br>设求出bx + ry = d 的一个解为x = x0, y = y0，考虑如何把它变形成ax + by = d 的解。<br>将a = bq + r 代入ax + by = d，化简得b(xq + y) + rx = d<br>我们令xq + y = x0, x = y0，则上式成立<br>故x = y0, y = x0 - y0q 为ax + by = d 的解<br>边界情况：b = 0 时，令x = 1, y = 0</p><h3 id="P1082-同余方程"><a href="#P1082-同余方程" class="headerlink" title="P1082 同余方程"></a>P1082 同余方程</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; pll;ll a, b;pll exgcd(ll a, ll b) &#123;    if(b &#x3D;&#x3D; 0) return &#123;1,0&#125;;    pll p &#x3D; exgcd(b, a%b);    return &#123;p.second, p.first-a&#x2F;b*p.second&#125;;&#125;int main() &#123;        scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b);    ll x &#x3D; exgcd(a,b).first;    while(x &lt; 0) x+&#x3D;b;    while(x-b &gt; 0) x-&#x3D;b;    printf(&quot;%lld\n&quot;, x);    return 0;&#125;</code></pre><h2 id="求不定方程所有解"><a href="#求不定方程所有解" class="headerlink" title="求不定方程所有解"></a>求不定方程所有解</h2><p>怎么求ax + by = c 的所有解？<br>先用exgcd 求出任意一个解x = x0, y = y0<br>再求出ax + by = 0 的最小的解<br>x = dx = b/(a, b), y = dy = -a/(a, b)<br>所有解就是x = x0 + kdx, y = y0 + kdy, k 取任意整数</p><h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>若ax ≡ 1(mod b)，则称x 是a 关于模b 的逆元，<br>常记做a−1。<br>回忆同余的性质。上式等价于ax + by = 1<br>如何求逆元？等价于解方程ax + by = 1<br>因此逆元不一定存在：<br>存在的充要条件为(a, b) = 1<br>推论：p 是质数，p 不整除a，则a 模p 的逆元存在。</p><p>结论：在[0, b) 的范围内，a 关于模b 的逆元(若存在) 是唯一的。<br>证明：<br>反证法，若a 有两个逆元0 &lt; x1 &lt; x2 &lt; b，<br>即ax1 ≡ ax2 ≡ 1(mod b)，<br>那么有b|a(x2 − x1) 成立<br>又由于(a, b) = 1，因此b|(x2 − x1)。<br>其中0 &lt; x2 − x1 &lt; b，产生了矛盾。</p><h3 id="P3811-【模板】乘法逆元"><a href="#P3811-【模板】乘法逆元" class="headerlink" title="P3811 【模板】乘法逆元"></a>P3811 【模板】乘法逆元</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;long long inv[int(3e6+10)]; int n, p;int main() &#123;        scanf(&quot;%d%d&quot;, &amp;n, &amp;p);    inv[1] &#x3D; 1;    for(int i&#x3D;2; i&lt;&#x3D;n; ++i) &#123;        inv[i] &#x3D; p-(p&#x2F;i)*inv[p%i]%p;    &#125;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) printf(&quot;%lld\n&quot;, inv[i]);    return 0;&#125;</code></pre><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>咕咕咕</p><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><p>如果看第一眼不会做，一般就得想一年的题，如臭名昭著的<strong>小凯类数论问题</strong></p><h3 id="P4942-小凯的数字"><a href="#P4942-小凯的数字" class="headerlink" title="P4942 小凯的数字"></a>P4942 小凯的数字</h3><p>我们知道，一个数模9等于他的各位和模9。这一结论可以推广至将某数截成若干节，每段合起来也符合这个规律，题目便转化成求sigma [l..r]。用 <code>__int128</code> 也可以过，但是更好是把除以二挪到前面，使其符合乘法取模分配率，注意奇偶。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;int a[15], b[15];int main() &#123;    int q; scanf(&quot;%d&quot;, &amp;q);    for(int i&#x3D;1; i&lt;&#x3D;q; ++i) &#123; LL l, r;        scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r);        if((r-l+1) %2 &#x3D;&#x3D; 0) printf(&quot;%lld\n&quot;, ((r-l+1)&#x2F;2)%9*(l+r)%9);        else printf(&quot;%lld\n&quot;, ((l+r)&#x2F;2)%9*(r-l+1)%9);    &#125;    return 0;&#125;</code></pre><h3 id="P3951-小凯的疑惑"><a href="#P3951-小凯的疑惑" class="headerlink" title="P3951 小凯的疑惑"></a>P3951 小凯的疑惑</h3><p>17年提高组出了好多屑题啊。。。这题连部分分都不给</p><p>而且我到现在还不会做。。。要是今年还出数论题估计就凉了 /kk</p><p>咕咕咕</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>裸题已经很少见了，但NOIp2017就出了这么一道。</p><h3 id="P3958-奶酪"><a href="#P3958-奶酪" class="headerlink" title="P3958 奶酪"></a>P3958 奶酪</h3><p>特点是自底至上找出通路，可以联想至森林合并。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N &#x3D; 1100;struct node &#123;    LL x, y, z;&#125; a[N];bool cmp(node a, node b) &#123;    return (a.z &lt; b.z);&#125;bool tp[N], bt[N];int fa[N], T, n;LL h, r;int root(int x) &#123;    return fa[x]&#x3D;&#x3D;x?x:root(fa[x]);&#125;bool check(int i, int j) &#123;    LL dist &#x3D; (a[i].x-a[j].x)*(a[i].x-a[j].x) + (a[i].y-a[j].y)*(a[i].y-a[j].y) + (a[i].z-a[j].z)*(a[i].z-a[j].z);    return dist &lt;&#x3D; 4*r*r;&#125;int main() &#123;        scanf(&quot;%d&quot;, &amp;T);    while(T--) &#123;        scanf(&quot;%d%lld%lld&quot;, &amp;n, &amp;h, &amp;r);        memset(bt, false, sizeof bt);        memset(tp, false, sizeof tp);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i)             scanf(&quot;%lld%lld%lld&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z);        sort(a+1, a+n+1, cmp);                for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;         if(a[i].z - r &lt;&#x3D; 0) bt[i] &#x3D; true;            if(a[i].z + r &gt;&#x3D; h) tp[i] &#x3D; true;        &#125;                for(int i&#x3D;1; i&lt;&#x3D;n; ++i) fa[i] &#x3D; i;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;            for(int j&#x3D;i+1; j&lt;&#x3D;n; ++j) &#123;                if(check(i, j)) &#123;                    fa[root(i)] &#x3D; root(j);                &#125;            &#125;        &#125;        bool fla &#x3D; false;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;            if(bt[i] &amp;&amp; tp[root(i)]) &#123;                fla &#x3D; true;                break;            &#125;        &#125;        printf(&quot;%s&quot;, (fla ? &quot;Yes\n&quot; : &quot;No\n&quot;));    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 普及组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="graph-theory/"/>
      <url>graph-theory/</url>
      
        <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>图论算法一般都是揉在一起的，很难单独把算法拆开讲，所以直接上题目吧。分类是大致分的，其实有很多是交叉的。</p><h2 id="最短路-amp-生成树"><a href="#最短路-amp-生成树" class="headerlink" title="最短路 &amp; 生成树"></a>最短路 &amp; 生成树</h2><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>多源最短路Floyd：严格 $O(n^3)$</li><li>单源最短路Dijkstra：</li><li><ul><li>朴素：严格 $O(n^2)$</li></ul></li><li><ul><li>优先队列优化：均摊 $O((e+n) \log n)$</li></ul></li><li>Bellman-Ford：</li><li><ul><li><b>最多松弛 $n-1$ 次</b></li></ul></li><li><ul><li>严格 $O(ne)$</li></ul></li><li>SPFA：</li><li><ul><li>即队列优化Bellman-Ford</li></ul></li><li><ul><li>最坏 $O(ne)$，最好 $O(1)$</li></ul></li></ul><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><p>咕咕咕</p><h3 id="如何卡掉-SPFA"><a href="#如何卡掉-SPFA" class="headerlink" title="如何卡掉 SPFA"></a>如何卡掉 SPFA</h3><p>见 <a href="https://www.zhihu.com/question/292283275/answer/484871888">https://www.zhihu.com/question/292283275/answer/484871888</a></p><h3 id="P1967-货车运输"><a href="#P1967-货车运输" class="headerlink" title="P1967 货车运输"></a>P1967 货车运输</h3><p>最大生成树，然后跑LCA</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 1e4+10, M &#x3D; 1e5+10, INF &#x3D; 0x3f3f3f3f;struct node &#123;    int id, u, v, w, next;&#125; e[M], e1[M];int h[N], tot &#x3D; 0, tot1 &#x3D; 0, n, m;int fa[N][15], dep[N], dis[N][15];int vis[N];bool edg[M];void add(int u, int v, int w) &#123;    e1[tot1] &#x3D; e[tot] &#x3D; &#123;tot, u, v, w, h[u]&#125;; h[u] &#x3D; tot++; tot1++;    e[tot] &#x3D; &#123;tot, v, u, w, h[v]&#125;; h[v] &#x3D; tot++;&#125;int bc[N];int root(int u) &#123;    return bc[u] &#x3D;&#x3D; u ? u : bc[u] &#x3D; root(bc[u]);&#125;bool cmp(node a, node b) &#123;    return a.w &gt; b.w;&#125;void dfs(int u, int f, int vi) &#123;    vis[u] &#x3D; vi;    for(int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;        int v &#x3D; e[i].v;        if(v &#x3D;&#x3D; f) continue;        if(edg[i] or edg[i^1]) &#123;            dep[v] &#x3D; dep[u] + 1;            fa[v][0] &#x3D; u;            dis[v][0] &#x3D; e[i].w;            dfs(v, u, vi);        &#125;    &#125;&#125;void lca(int x, int y) &#123;    if(dep[x] &lt; dep[y]) swap(x, y);    int ans &#x3D; INF;    int t &#x3D; dep[x] - dep[y];    for(int i&#x3D;14; i&gt;&#x3D;0; --i) &#123;        if(t &gt;&#x3D; (1&lt;&lt;i)) &#123;            ans &#x3D; min(ans, dis[x][i]);            x &#x3D; fa[x][i];            t -&#x3D; (1&lt;&lt;i);        &#125;    &#125;    if(x &#x3D;&#x3D; y) &#123;        printf(&quot;%d\n&quot;, ans);        return;    &#125;    for(int i&#x3D;14; i&gt;&#x3D;0; --i) &#123;        if(fa[x][i] !&#x3D; fa[y][i]) &#123;            ans &#x3D; min(ans, dis[x][i]);            ans &#x3D; min(ans, dis[y][i]);            x &#x3D; fa[x][i]; y &#x3D; fa[y][i];        &#125;    &#125;    &#x2F;&#x2F;printf(&quot;lca:%d\n&quot;, fa[x][0]);    printf(&quot;%d\n&quot;, min(ans, min(dis[x][0], dis[y][0])));&#125;int main() &#123;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    memset(h, -1, sizeof h);    for(int i&#x3D;1; i&lt;&#x3D;m; ++i) &#123;        int u, v, w;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        add(u, v, w);    &#125;        sort(e1, e1+tot1, cmp);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) bc[i] &#x3D; i;    for(int i&#x3D;0; i&lt;tot1; ++i) &#123;    int u &#x3D; e1[i].u, v &#x3D; e1[i].v;    int u1 &#x3D; root(u), v1 &#x3D; root(v);    if(u1 !&#x3D; v1) &#123;    edg[e1[i].id] &#x3D; true;    bc[v1] &#x3D; u1;        &#125;    &#125;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        if(bc[i] &#x3D;&#x3D; i) &#123;            dfs(i, 0, i);            for(int j&#x3D;0; j&lt;&#x3D;14; ++j) &#123;                fa[i][j] &#x3D; i;                dis[i][j] &#x3D; INF;            &#125;        &#125;    &#125;        for(int i&#x3D;1; i&lt;&#x3D;14; ++i) &#123;        for(int j&#x3D;1; j&lt;&#x3D;n; ++j) &#123;            fa[j][i] &#x3D; fa[fa[j][i-1]][i-1];            dis[j][i] &#x3D; min(dis[j][i-1], dis[fa[j][i-1]][i-1]);        &#125;    &#125;        int query; scanf(&quot;%d&quot;, &amp;query);    for(int i&#x3D;1; i&lt;&#x3D;query; ++i) &#123;         int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        if(vis[x] !&#x3D; vis[y]) &#123; printf(&quot;-1\n&quot;); continue; &#125;        lca(x, y);    &#125;        return 0;&#125; </code></pre><h3 id="P1073-最优贸易"><a href="#P1073-最优贸易" class="headerlink" title="P1073 最优贸易"></a>P1073 最优贸易</h3><p>分层图，最短路</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;limits.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int N &#x3D; 330000, M &#x3D; 1650000;struct node &#123;    int u, v, w, next;    node() &#123;&#125;    node(int _u, int _v, int _w, int _next): u(_u), v(_v), w(_w), next(_next) &#123;&#125;&#125; e[M &lt;&lt; 1];int h[N], tot &#x3D; 0;inline void add(int u, int v, int w &#x3D; 0) &#123;    e[tot] &#x3D; node(u, v, w, h[u]);    h[u] &#x3D; tot++;&#125;int n, m, w[N]; bool vis[N]; int dis[N];int main() &#123;        #ifdef DEBUG    freopen(&quot;p1073_1.in&quot;, &quot;r&quot;, stdin);    #endif    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        scanf(&quot;%d&quot;, &amp;w[i]);    &#125;    memset(h, -1, sizeof h);    for(int i&#x3D;1, x, y, z; i&lt;&#x3D;m; ++i) &#123;        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);        if(z &#x3D;&#x3D; 1) add(x, y), add(x+n, y+n), add(x+2*n, y+2*n);        else &#123;            add(x, y), add(x+n, y+n), add(x+2*n, y+2*n);            swap(x, y);            add(x, y), add(x+n, y+n), add(x+2*n, y+2*n);        &#125;    &#125;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        add(i+n, i, w[i]);        add(i, i+2*n, -w[i]);    &#125;        queue&lt;int&gt; q;        memset(dis, 0x3f, sizeof dis);    q.push(n+1); vis[n+1] &#x3D; true; dis[n+1] &#x3D; 0;    while(!q.empty()) &#123;        int u &#x3D; q.front();        q.pop(); vis[u] &#x3D; false;        for(int i&#x3D;h[u]; i!&#x3D;-1; i&#x3D;e[i].next) &#123;            int v&#x3D;e[i].v;            if(dis[v] &gt; dis[u] + e[i].w) &#123;                dis[v] &#x3D; dis[u] + e[i].w;                if(!vis[v]) &#123;                    q.push(v);                    vis[v] &#x3D; true;                &#125;            &#125;        &#125;     &#125;        printf(&quot;%d\n&quot;, -dis[n*3]);        return 0;&#125;</code></pre><h2 id="P1119-灾后重建"><a href="#P1119-灾后重建" class="headerlink" title="P1119 灾后重建"></a>P1119 灾后重建</h2><p><b>很重要的题目，考察了 Floyd的本质。</b></p><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>用 $dis[k][i][j]$ 表示 i 和 j 之间可以通过编号为 $1\dots k$ 的节点的最短路径，显然，$dis[0][i][j]$ 就是原始邻接矩阵数据。</p><p>状态转移方程：</p><p>$$<br>dis[k][i][j]=min(dis[k-1][i][j],dis[k-1][i][k]+dis[k-1][k][j])<br>$$</p><p>$$<br>dis[k][i][j]=min(dis[k-1][i][j],dis[k-1][i][k]+dis[k-1][k][j])<br>$$</p><p>Floyd 的本质其实就是DP，只不过我们通常做题时利用了数据只会使用一次性的原理，把 dis 变成滚动数组，减少了一维，节省空间。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;提前将邻接矩阵存在 dis 数组里，其他不连通的地方初始化成无穷大for(int k&#x3D;1; k&lt;&#x3D;n; ++k) &#x2F;&#x2F;枚举中间点    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#x2F;&#x2F;枚举起点        if(i !&#x3D; k) &#x2F;&#x2F;节省时间，如果一样就不往下走            for(int j&#x3D;1; j&lt;&#x3D;n; ++j) &#x2F;&#x2F;枚举终点                if(i !&#x3D; j and j !&#x3D; k) &#x2F;&#x2F;继续判断，如果有一样的就不往下走                    dis[i][j] &#x3D; min(dis[i][j], dis[i][k] + dis[k][j]); &#x2F;&#x2F;状态转移方程，也就是所谓的松弛操作</code></pre><p><b>只要我们能够利用 DP 特性，就能解决许多问题</b></p><p>再回来看这道题，文中说每个村子是不同时间修好的，而每个节点都按顺序给出，这不就是恰好相当于 Floyd的中间点吗？我们可以把 k轮 DP分开做，每输入一个点，就用这个点当中转站把最短距离更新一遍，也就是跑一遍 DP。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 220;int t[N];struct query &#123;    int id, x, y, t;&#125; a[55000];int res[55000], n, m, dp[N][N];int main() &#123;        &#x2F;&#x2F;freopen(&quot;P1119_2.in&quot;, &quot;r&quot;, stdin);         scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        scanf(&quot;%d&quot;, t+i);    &#125;    t[n+1] &#x3D; 0x3f3f3f3f;        memset(dp, 0x3f, sizeof dp);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) dp[i][i] &#x3D; 0;    for(int i&#x3D;1; i&lt;&#x3D;m; ++i) &#123; int u, v, w;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); ++u, ++v;        dp[u][v] &#x3D; dp[v][u] &#x3D; w;    &#125;    int q;    scanf(&quot;%d&quot;, &amp;q);    for(int i&#x3D;1; i&lt;&#x3D;q; ++i) &#123;        scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].t);        a[i].id &#x3D; i; ++a[i].x, ++a[i].y;     &#125;        int cnt &#x3D; 1;    for(; a[cnt].t &lt; t[1]; ++cnt) &#123;        res[a[cnt].id] &#x3D; -1;     &#125;        for(int T&#x3D;1; T&lt;&#x3D;n; ++T) &#123;                for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;            for(int j&#x3D;1; j&lt;&#x3D;n; ++j) &#123;                dp[i][j] &#x3D; min(dp[i][j], dp[i][T] + dp[T][j]);            &#125;        &#125;                    while(1) &#123;            if(cnt &gt; q) break;            if(a[cnt].t &gt;&#x3D; t[T] and a[cnt].t &lt; t[T+1]); else break;            if(a[cnt].x &gt; T or a[cnt].y &gt; T or dp[a[cnt].x][a[cnt].y] &#x3D;&#x3D; 0x3f3f3f3f) &#123;                res[a[cnt].id] &#x3D; -1;            &#125; else &#123;                res[a[cnt].id] &#x3D; dp[a[cnt].x][a[cnt].y];            &#125;            ++cnt;        &#125;    &#125;        for(int i&#x3D;1; i&lt;&#x3D;q; ++i) printf(&quot;%d\n&quot;, res[i]);    return 0;&#125;</code></pre><h2 id="判负环"><a href="#判负环" class="headerlink" title="判负环"></a>判负环</h2><p>转自 @SingerCoder，%lgh</p><div class="note default flat"><p>注意一定要判入队次数而不是松弛次数。</p><p>hack原理很简单：如果存在重边导致了多次松弛，那么对松弛次数的判断就会产生影响。解决方式就是判入队次数，虽然略慢，但是更稳。</p><p>Update[2020.7.26]：在写差分约束的时候想用spfa判无解，然后经过一系列的思考就有了下面这组新的hack数据：</p><pre class="line-numbers language-none"><code class="language-none">input:14 61 2 -31 3 -21 4 -12 3 -62 4 -53 4 -4output:NO</code></pre><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/cdn2/g21s.png"></p><p>注意这组hack只对用链式前向星（而非vector）存边且判的是松弛次数（而非入队次数）的有效，而且该数据无重边无自环，比discuss里面的那个数据更有说服力。</p><p>首先hack原理就是对n号节点进行n-1轮松弛，每轮都有 $x( x \in [1,n-1])$ 次松弛，这样就能产生 $n^2$ 级别的松弛次数。</p><p>但是判入队次数就hack不掉了，每轮的第一次松弛会让n节点入队，但n节点只有在下一轮才会出队；因此本轮的其余所有松弛全部无法导致入队。</p></div><h3 id="P3385-模板-负环"><a href="#P3385-模板-负环" class="headerlink" title="P3385 [模板]负环"></a>P3385 [模板]负环</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 2e3 + 10, M &#x3D; 6e3 + 10;struct node &#123;    int u, v, w, next;&#125; e[M];int h[N], tot &#x3D; 0;int T, n, m;inline void add(int u, int v, int w) &#123;    e[++tot] &#x3D; &#123;u, v, w, h[u]&#125;; h[u] &#x3D; tot;&#125; int dis[N], vis[N];bool inq[N];inline void spfa() &#123;        queue&lt;int&gt; q;    memset(dis, 0x3f, sizeof dis);    memset(vis, 0, sizeof vis);    memset(inq, false, sizeof inq);        dis[1] &#x3D; 0; q.push(1); inq[1] &#x3D; true; ++vis[1];    while(!q.empty()) &#123;                int u &#x3D; q.front(); q.pop(); inq[u] &#x3D; false;&#x2F;&#x2F;printf(&quot;%d\n&quot;, u);        for(int i &#x3D; h[u]; i ; i &#x3D; e[i].next) &#123;            int v &#x3D; e[i].v;            if(dis[v] &gt; dis[u] + e[i].w) &#123;                dis[v] &#x3D; dis[u] + e[i].w;                if(!inq[v]) &#123;                    inq[v] &#x3D; true;                    ++vis[v];                    if(vis[v] &gt; n-1) &#123;                        printf(&quot;YES\n&quot;);                        return;                    &#125;                    q.push(v);                &#125;            &#125;        &#125;    &#125;    printf(&quot;NO\n&quot;);&#125;int main() &#123;        &#x2F;&#x2F;freopen(&quot;P3385_2.in&quot;, &quot;r&quot;, stdin);        scanf(&quot;%d&quot;, &amp;T);    while(T--) &#123;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        memset(h, 0, sizeof h); tot &#x3D; 0;        for(int i&#x3D;1; i&lt;&#x3D;m; ++i) &#123;            int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);            if(w &gt;&#x3D; 0) &#123;                add(u, v, w);                add(v, u, w);            &#125; else add(u, v, w);            &#x2F;&#x2F;printf(&quot;%d &quot;, i);        &#125;        spfa();    &#125;    return 0;&#125;</code></pre><h2 id="基环树"><a href="#基环树" class="headerlink" title="基环树"></a>基环树</h2><p>n 个点 n 条边 只有一个环 枚举断边</p><h3 id="P5022-NOIp2018TG-旅行"><a href="#P5022-NOIp2018TG-旅行" class="headerlink" title="P5022 [NOIp2018TG]旅行"></a>P5022 [NOIp2018TG]旅行</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>涉江</title>
      <link href="she-jiang/"/>
      <url>she-jiang/</url>
      
        <content type="html"><![CDATA[<h2 id="涉江"><a href="#涉江" class="headerlink" title="涉江"></a>涉江</h2><div class="note default flat"><p>公无渡河。公竟渡河。</p><p>堕河而死。其奈公何。</p></div><p>&emsp;&emsp;E 座的尽头是一扇窗。她喜欢伏在那里的窗棂上，很多个课间。窗外是一幢天井；三面环楼，夐不见曦。</p><p>&emsp;&emsp;天井的中央是一台鱼池。一到每年新生入学的时候，鱼们便如笋般冒了出来，流水潺潺，清荣峻茂；整个学校也像鱼池一样变得活络了起来。人们的脸上总是挂着笑容；鱼池旁也缀上了很多人影，来来往往的。</p><p>&emsp;&emsp;她的背后是一道走廊，连结着初中部和高一年级。原则上，高一的饮水机坏了，才会有人从这里经过，就比如这几天；那边的机器更高端，相传有四个水龙头。她听高三的学长们说，原先这里本是熙熙攘攘，那一年却突然间就变了天。或许今后也会有那一年吧。走廊里时常有行为艺术家们走过，小嘴抹蜜，应节而舞，免不了一群男女从旁指点，逼逼赖赖。也有三三两两的女生们，攒聚喁喁。偶尔天亮的时候，也会有许多男同，两两联会，而姐妹相称。</p><p>&emsp;&emsp;但这些都与她无关。她相信未来，相信辰星在无边的旷野，正如大多数人一样。她可能还没有想到过那样的一天，雪花浸满了每一个角落。空自，她守望着梦乡。</p><p>&emsp;&emsp;楼下有一群人走过，为首的迨着球。教室里传来九日的声响。他似乎看见了她。她的思绪仍然飘在远方，漠然颔首。</p><p>&emsp;&emsp;他们走上楼来。他一迳向 E 座的尽头走去。值勤的女生认出了他，嘴唇微微动了动，遽把脸扭了过去，没有作声。他也照着做了。那扇窗静静地在那里；窗闩没有扣严，被一阵狂风吹散了。他正要上前，风却一瞬间弱了下去。太阳拐了一个弯；和煦的光洒遍了他和她的窗。微风摩挲着窗扇，像一只系在法线上的蝴蝶。</p><p>&emsp;&emsp;她和他站在那里，看着归帆迤逦着向远方飘散。日光投靠在他的身侧，渲染出几许明媚的景致来，蹦跳着走远了。水波轻轻地颤动着。月亮干咳了几下，发出沙沙的响声，挑达在城阙上。兰麝香仍在，珮环声渐远。</p><div class="note success flat"><p>未完待续</p></div>]]></content>
      
      
      <categories>
          
          <category> 小说 &amp; 随笔 </category>
          
          <category> 陌上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还在用 STL 排序？</title>
      <link href="still-using-stl-sort/"/>
      <url>still-using-stl-sort/</url>
      
        <content type="html"><![CDATA[<p><strong>还在用 STL 排序？</strong></p><h4 id="使用-C-库函数"><a href="#使用-C-库函数" class="headerlink" title="使用 C 库函数"></a>使用 C 库函数</h4><p>很多人都不知道的是，其实 C 语言也是自带排序函数的，就是位于 <code>&lt;stdlib.h&gt;</code> 库中的 <code>qsort</code></p><p>函数声明：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</code></pre><p>其中</p><ul><li><strong>base</strong> - 指向要排序的数组的第一个元素的指针</li><li><strong>nitems</strong> - base 指向的数组中元素的个数</li><li><strong>size</strong> - 数组中每个元素的大小（以字节为单位）</li><li><strong>compar</strong> - 用来比较两个元素的函数</li></ul><p>与  <code>&lt;algorithm&gt;</code>  中的 <code>std::sort</code> 略有差异，尤其是在 <code>compar</code> 函数的定义上。</p><p>其形参必须是 <code>const void*</code> 型（可以理解为，在 <code>compar</code> 函数内部会将 <code>const void*</code> 型转换成实际类型）。</p><ul><li>如果返回值小于0（&lt; 0），那么p1所指向元素会被排在p2所指向元素的左面；</li><li>如果返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定；</li><li>如果返回值大于0（&gt; 0），那么p1所指向元素会被排在p2所指向元素的右面。</li></ul><p>在 <code>C11</code> 标准中，新增了另一个排序函数 <code>qsort_s</code> ，但在无编译开关的情况下无法使用。</p><p>另外，虽然它的名字叫 <code>qsort</code> ，但目前还没有任何一个 C 标准规定其必须通过快排实现（）</p><p>实测在整数排序下，效率与 <code>STL</code> 相差无几，都在 <code>140ms/1.20MB</code> 左右。</p><p><strong>Code (C) :</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;const int N &#x3D; 1e5 + 10;int cmp(const void *a, const void *b) &#123;    return (*(int*)a - *(int*)b);&#125;int main() &#123;    int n, i, a[N];    scanf(&quot;%d&quot;, &amp;n);    for (i&#x3D;0; i&lt;n; ++i) scanf(&quot;%d&quot;, a+i);    qsort(a, n, sizeof(int), cmp);    for (i&#x3D;0; i&lt;n-1; ++i) printf(&quot;%d &quot;, a[i]);    printf(&quot;%d\n&quot;, a[n-1]);    return 0;&#125;</code></pre><h4 id="使用-PB-DS"><a href="#使用-PB-DS" class="headerlink" title="使用 PB_DS"></a>使用 PB_DS</h4><p><code>PB_DS</code>，<del>又称平板电视</del>，是一个冷门但功能极为强大的 <code>GNU-C++</code> 扩展库，但在 <code>OI</code> 中（尤其是省选以下）极少用到。</p><p>该库中提供了大量数据结构（<del>虽然不开O2的话几乎都会T掉</del>），以树形结构为主，<del>拿出来基本个个都可以排序</del></p><p><strong>堆：</strong></p><p>（未开 O2，<code>248ms/5.23MB</code> ）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;#include &lt;bits&#x2F;extc++.h&gt;using namespace std;using namespace __gnu_pbds;__gnu_pbds::priority_queue &lt; int, greater&lt;int&gt;, pairing_heap_tag &gt; q;int n;int main() &#123;    scanf(&quot;%d&quot;, &amp;n);    for(int i&#x3D;0, a; i&lt;n; ++i) scanf(&quot;%d&quot;, &amp;a), q.push(a);     for(int i&#x3D;0; i&lt;n; ++i) printf(&quot;%d &quot;, q.top()), q.pop();    return 0;&#125;</code></pre><p>由于 <code>pb_ds</code> 中的 <code>tree</code> 相当于 <code>set</code> 而不是 <code>multiset</code> ，因此<del>比手写快排还长</del>，不再展示。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> STL </tag>
            
            <tag> 算法 </tag>
            
            <tag> PB_DS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流：最大流</title>
      <link href="maximum-flow/"/>
      <url>maximum-flow/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流：最大流"><a href="#网络流：最大流" class="headerlink" title="网络流：最大流"></a>网络流：最大流</h1><h2 id="EK"><a href="#EK" class="headerlink" title="EK"></a>EK</h2><p>增广路方法是很多网络流算法的基础。其思路是每次找出一条从源到汇的<strong>能够增加流的路径</strong>，调整流值和残留网络 ，<strong>直到没有增广路为止</strong>。</p><p>EK 算法就是不断的找最短路，找的方法就是每次找一条<strong>边数最少</strong>的增广（即最短路径增广）。</p><h3 id="最多要增广多少次？"><a href="#最多要增广多少次？" class="headerlink" title="最多要增广多少次？"></a>最多要增广多少次？</h3><p>可以证明，<b>最多 O(VE)</b>​ 次增广，可以达到最大流。</p><h3 id="如何找到一条增广路？"><a href="#如何找到一条增广路？" class="headerlink" title="如何找到一条增广路？"></a>如何找到一条增广路？</h3><p>先明确什么是增广路。增广路是一条从s到t的路径，路径上每条边残留容量都为正。把残留容量为正的边设为可行的边，那么我们就可以用简单的 <strong>BFS</strong> 得到边数最少的增广路。</p><h3 id="如何增广？"><a href="#如何增广？" class="headerlink" title="如何增广？"></a>如何增广？</h3><p>BFS 得到增广路之后，这条增广路能够增广的流值，是路径上<strong>最小残留容量边</strong>决定的。把这个最小残留容量 MinCap 值加到最大流值 Flow 上，同时路径上每条边的残留容量值减去 MinCap；最后，<strong>路径上每条边的反向边残留容量值要加上 MinCap</strong>。这样每次增广的复杂度为 <b>O(E)</b>，总复杂度就是 <b>O(VE<sup>2</sup>)</b>。事实上，大多数网络的增广次数很少，因此 EK 算法能处理绝大多数问题。</p><h3 id="为什么增广路径上每条边的反向边残留容量值要加上-MinCap？"><a href="#为什么增广路径上每条边的反向边残留容量值要加上-MinCap？" class="headerlink" title="为什么增广路径上每条边的反向边残留容量值要加上 MinCap？"></a>为什么增广路径上每条边的反向边残留容量值要加上 MinCap？</h3><p><strong>残留网络 = 容量网络 - 流量网络</strong></p><p>容量网络不改变的情况下，由于增广好比给增广路上通了一条流，路径上所有边流量加 MinCap 之后，相对应的残留网络就发生<strong>相反</strong>的改变。因为建立了反向边，如果这条路径不是最理想的就会回流，避免了这种情况。这是网络流里很重要的一点。</p><h3 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h3><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/flow1.png" alt="img"></p><h2 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h2><h3 id="BFS-分层"><a href="#BFS-分层" class="headerlink" title="BFS 分层"></a>BFS 分层</h3><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3378169721,650522187&fm=173&app=25&f=JPEG?w=640&h=360&s=45B43D7215EAD4E3186890DE000080B3" alt="img"></p><p>与EK一样，我们仍要通过 bfs 来判断图中是否还存在增广路，但是 Dinic 算法里的 bfs 略有不同。这次，我们不用记录路径，而是给每一个点分层，对于任意点 i，从 s 到 i 每多走过一个点，就让层数多 1。一次分层后可以找到多条增广路，从而提高效率。</p><p>分完层效果是这样的：（蓝色的数字是每个点层数）</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1570035932,108109570&fm=173&app=25&f=JPEG?w=640&h=360&s=44B42D7215EAD4E3187890DE000080B3" alt="img"></p><h3 id="DFS-增广"><a href="#DFS-增广" class="headerlink" title="DFS 增广"></a>DFS 增广</h3><p>有了每个点的层数编号，对任意点 u 到点 d 的路径如果有 $dep[d]=dep[u]+1$，我们就可以判断该路径在增广路上。</p><p>比如说，我们首先找 s-&gt;1-&gt;4-&gt;t：</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3046893860,1762669248&fm=173&app=25&f=JPEG?w=640&h=360&s=44B4297215EAD4E71C6890DE000080B3" alt="img"></p><p>第二次，s-&gt;1-&gt;5-&gt;t：</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=540564913,3708139900&fm=173&app=25&f=JPEG?w=640&h=360&s=64B4A87215EAD4E71C6C90DE000080B3" alt="img"></p><p>第三次，s-&gt;1-&gt;3-&gt;t：</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3523190815,2305233655&fm=173&app=25&f=JPEG?w=640&h=360&s=05B6ED3215EAD4E7186490DE000080B3" alt="img"></p><p>还有第四条，s-&gt;2-&gt;3-&gt;t：</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1230633075,4211996757&fm=173&app=25&f=JPEG?w=640&h=360&s=05B4E93215EAD4E7186090DE0000C0B3" alt="img"></p><p><strong>PS：Dinic 在跑二分图匹配时比匈牙利快很多。</strong></p><h2 id="P3376-网络最大流"><a href="#P3376-网络最大流" class="headerlink" title="P3376 网络最大流"></a>P3376 网络最大流</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 11000, M &#x3D; 110000;const int INF &#x3D; 0x7fffffff;struct node &#123;    int u, v, w, next;&#125; e[M &lt;&lt; 1];int cur[N], h[N], tot;int dfn[N], ans, n, m, s, t;void add(int u, int v, int w) &#123;    e[tot] &#x3D; node(&#123;u, v, w, h[u]&#125;);    cur[u] &#x3D; h[u] &#x3D; tot++;&#125;bool bfs() &#123;    memcpy(cur, h, sizeof cur);    memset(dfn, 0, sizeof dfn);    queue&lt;int&gt; q;    dfn[s] &#x3D; 1;    q.push(s);    while(!q.empty()) &#123;        int u &#x3D; q.front();        q.pop();        for(int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;            int v &#x3D; e[i].v;            if(e[i].w and !dfn[v]) &#123;                dfn[v] &#x3D; dfn[u] + 1;                q.push(v);                if(v &#x3D;&#x3D; t) return true;            &#125;        &#125;    &#125;    return false;&#125;int dfs(int u, int low) &#123;    if(u &#x3D;&#x3D; t) return low;    int w &#x3D; low;    for(int i &#x3D; cur[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;        int v &#x3D; e[i].v;        cur[u] &#x3D; i;        if(e[i].w and dfn[v] &#x3D;&#x3D; dfn[u] + 1) &#123;            int f &#x3D; dfs(v, min(w, e[i].w));            if(f &#x3D;&#x3D; 0) dfn[v] &#x3D; 0;            e[i].w -&#x3D; f; e[i^1].w +&#x3D; f;            w -&#x3D; f;            if(!w) break;        &#125;    &#125;    return low - w;&#125;void dinic() &#123;    int flow;    while(bfs()) while(flow &#x3D; dfs(s, INF)) ans +&#x3D; flow;&#125;int main() &#123;    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    memset(h, -1, sizeof h);    for(int i&#x3D;1, u, v, w; i&lt;&#x3D;m; ++i) &#123;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        add(u, v, w);        add(v, u, 0);    &#125;    dinic();    printf(&quot;%d\n&quot;, ans);    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流：最小割</title>
      <link href="minimum-cut/"/>
      <url>minimum-cut/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流：最小割"><a href="#网络流：最小割" class="headerlink" title="网络流：最小割"></a>网络流：最小割</h1><p>将图 $G$ 分为 $A$ 和 $B$ 两个点集，$A$ 和 $B$ 之间的边的集合称为无向图的<b>割集</b>。带权图的<b>割 (Cut) </b>就是割集中的边权之和。</p><h2 id="S-T-最小割"><a href="#S-T-最小割" class="headerlink" title="S - T 最小割"></a>S - T 最小割</h2><p>特别地，对于一个网络，在满足 $源点 s \in 点集{S}, 汇点 t \in 点集{T}(S\cap T= \varnothing)$ 的情况下，<b>从 S 到 T 的边的权值和</b>被称为 <b>S 到 T 的割</b>。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/cut1.png" alt="img"></p><p>通俗地说，如果把你家和自来水厂之间的水管网络砍断了一些，那么自来水厂无论怎么放水，水都无法到达你们家，自然就停水了，砍掉的水管就是割。</p><p>砍水管的人自然希望花的力气越小越好。在所有割中，权值和最小的称为<strong>最小割</strong>。对于一个给定的 S - T 网络，如何求出它的最小割呢？</p><h2 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h2><p><b>网络的最大流等于最小割。</b></p><p>这个定理看起来很简单，但是真去思考的话其实是很麻烦的。</p><h3 id="证明-Step-1：任意一个流都小于等于任意一个割"><a href="#证明-Step-1：任意一个流都小于等于任意一个割" class="headerlink" title="证明 Step 1：任意一个流都小于等于任意一个割"></a>证明 Step 1：任意一个流都小于等于任意一个割</h3><p>自来水公司随便给你家通点水，构成一个流，随便砍几刀砍出一个割，那么由于容量限制，每一根的被砍的水管子流出的水流量都小于管子的容量。每一根被砍的水管的水本来都要到你家的，现在流到外面，加起来得到的流量还是等于原来的流。而管子的容量加起来就是割，所以流小于等于割。</p><p>由于上面的流和割都是任意构造的，所以<strong>任意一个流小于任意一个割</strong>，即<br>$$<br>\forall F \leqslant \forall C<br>$$</p><h3 id="Step-2：构造出一个流，使它等于一个割"><a href="#Step-2：构造出一个流，使它等于一个割" class="headerlink" title="Step 2：构造出一个流，使它等于一个割"></a>Step 2：构造出一个流，使它等于一个割</h3><p>当达到最大流时，根据增广路定理，残留网络中 s 到 t 已经没有通路了。因此，若把残余网络中 s 能到的的点的集合设为 S，不能到的点集为 T ，构造出一个割集 $C[点集S,点集T]$，所有由 S 发往 T 的边必然满流。并且，这些满流边的流量和就是当前的流，即<strong>最大流</strong>。把这些满流边作为割，就构造出了一个<strong>和最大流相等的割</strong>。</p><h3 id="Step-3：最大流等于最小割"><a href="#Step-3：最大流等于最小割" class="headerlink" title="Step 3：最大流等于最小割"></a>Step 3：最大流等于最小割</h3><p>设上一步构造出流和割分别为 $F_m$ 和 $C_m$。</p><p>又 $\forall F \leqslant \forall C$</p><p>$\therefore \forall F \leqslant F_m=C_m \leqslant \forall C$。</p><h3 id="网络流等价定理"><a href="#网络流等价定理" class="headerlink" title="网络流等价定理"></a>网络流等价定理</h3><p>（这个名字是我自己想的</p><p>综合最大流最小割定理和增广路定理，可以得到这样的结论：</p><blockquote><p>对于一个网络流图 $G=(V,E)$，其中有源点 $s$ 和汇点 $t$ ，那么下面三个条件是等价的：</p><ol><li><p>流 $f$ 是图 $G$ 的最大流；</p></li><li><p>残留网络 $G$ 不存在增广路；</p></li><li><p>在 $G$ 中必存在一个割 $C[S,T]$，使得 $f=C[S,T]$。</p></li></ol></blockquote><p><del>读者自证不难</del></p><h3 id="证明-1-gt-2（即增广路定理）"><a href="#证明-1-gt-2（即增广路定理）" class="headerlink" title="证明 1 =&gt; 2（即增广路定理）"></a>证明 1 =&gt; 2（即增广路定理）</h3><p>利用反证法，假设流 $f$ 是图 $G$ 的最大流，但是残留网络中还存在有增广路 $p$，其流量为 $f_p$，则有流 $f’=f+f_p&gt;f$。这与 $f$ 是最大流产生矛盾。</p><h3 id="证明-2-gt-3（即最大流最小割定理）"><a href="#证明-2-gt-3（即最大流最小割定理）" class="headerlink" title="证明 2 =&gt; 3（即最大流最小割定理）"></a>证明 2 =&gt; 3（即最大流最小割定理）</h3><p>总结一下上面的证明。</p><p>假设残留网络 $G_f$ 不存在增广路，所以在残留网络 $G_f$ 中不存在路径从 $s$ 到达 $t$。我们定义 $S$ 集合为当前残留网络中 $s$ 能够到达的点，同时定义 $T=V-S$，此时构成一个割 $C(S,T)$。</p><p>且 $u∈S,v∈T$，有 $f(u,v)=c(u,v)$。若 $f(u,v)&lt;c(u,v)$，则有 $G_f(u,v)&gt;0$，$s$ 可以到达 $v$，与 $v \in T$ 矛盾。</p><p>因此有 $f(S,T)= \sum f(u,v)=\sum c(u,v)=C(S,T)$。</p><h3 id="证明-3-gt-1："><a href="#证明-3-gt-1：" class="headerlink" title="证明 3 =&gt; 1："></a>证明 3 =&gt; 1：</h3><p>由于 $f$ 的上界为最小割，当 $f$ 到达割的容量时，显然就已经到达最大值，因此 $f$ 为最大流。</p><p>这样就说明了为什么找不到增广路时，所求得的一定是最大流。</p><h2 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h2><p>在一个图中，我们选取一些点构成集合，记为 V，且集合中的出边（即集合中的点的向外连出的弧），所指向的终点也在 V 中，则我们称 V 为闭合图。在所有闭合图中，集合中点的权值之和最大的 V，称为<strong>最大权闭合子图</strong>。</p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/cutt.png" alt="img"></p><p>上图中最大权闭合子图为 {3,4,5}。</p><h2 id="最大权闭合子图权值和"><a href="#最大权闭合子图权值和" class="headerlink" title="最大权闭合子图权值和"></a>最大权闭合子图权值和</h2><h3 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h3><p>构建一个超级源点 s，一个超级汇点 t，所有的点按权值的正负连接到 s 和 t 上，转换成一个边权值有向图，如下图：</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/cut2.png" alt="img"></p><p>（注：点权为 0 的点可以忽略，对结果没有影响）</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>该带边权有向图的 S - T 最小割，割集中所有的边，都与 s 或 t 相连接。</li></ul><blockquote><p>显然，因为不与 s,t 相连的边，权值都是 INF，最小割不可能割在 INF 的边上。</p></blockquote><ul><li>该图中的每一个简单割产生的两个子图，我们记含有点 s 的是图 S，含有点 t 的是图 T，则图 S 是最大权闭合子图。</li></ul><blockquote><p>简单割内不包含边权为 INF 的边，即不含有连通两个图的边（除了连接在 t 点上的边之外）；即，图 S 中没有边与图 T 连通，那么，所有的边都只能连接在图 S 之内，即为闭合图。</p></blockquote><p>记割集中，所有连接在 s 上的边的权值和为 $x_1$，所有连接在 t 上的边的权值和为 $x_2$，则割集中所有边权值和为 $x=x_1+x_2$。</p><p>记图 S 中所有点的权值和为 $w$，记其中正权值之和为 $w_1$，负权值之和为 $- w_2$，故 $w = w_1 - w_2$。</p><p>因此，<br>$$<br>w+x=w_1-w_2+x_1-x_2<br>$$<br>又 ，<br>$$<br>x_2 = w_2<br>$$<br>因为图 S 中所有负权值的点必然连接到 t 点，而图 S 必然要与 t 分割开，故割集中，<strong>连接在 t 点上的边权值和</strong>就是<strong>图S中所有负权值点的权值之和取负</strong>。因而，<br>$$<br>w+x=w_1+x_1<br>$$<br>显然，$w_1 + x_1$ 是整个图中所有正权值之和，记为 $sum$，则<br>$$<br>w=sum-x<br>$$<br>即，<strong>图 S 中所有点的权值和 = 整个图中所有正权值之和 - 割集中所有边权值和</strong>。因为 $sum$ 为定值，只要我们取最小割，则<strong>图 S 中所有点的权值和</strong>就是最大的，即此时图 S 为最大权闭合子图。</p><h3 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子"></a>栗子</h3><p>　　　　　<img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/cut3.png" alt="img">　　　　　<img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/cut4.png" alt="img"></p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ul><li><p>先记录整个图中，所有正点权值的和；</p></li><li><p>建立对应流网络，求最大流，最大流在数值上等于最小割，故我们得到了流网络的 s-t 最小割；</p></li><li><p><strong>所有正点权值的和</strong>减去 <strong>s-t 最小割</strong>，即得最大权闭合子图的权值和。</p></li></ul><h2 id="P2762-太空飞行计划问题"><a href="#P2762-太空飞行计划问题" class="headerlink" title="P2762 太空飞行计划问题"></a>P2762 太空飞行计划问题</h2><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>这里大概讲一下转换成最大流以后怎么输出。</p><p>一个结论就是假如我们跑的是 Dinic 那么我们最后一次网络流（这一次网络流并没有起任何作用，只是确认了无更多残余流量可以退出了）中，所有被分到层的都一定被选上了。</p><p>没有更多残余流量其实意味着这个图已经被割成了两部分，一个实验如果有层数意味着它没有被割掉（被选上了），一个仪器如果有层数意味着它已经被割掉了（也是被选上了）。</p><p>于是只要在最后输出所有有层数的点就行了。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 110, INF &#x3D; 0x3f3f3f3f;char tools[10000];class node &#123;    public:        int u, v, w, next;&#125; e[N * N];int head[N], cur[N], tot &#x3D; 0;void add(int u, int v, int w) &#123;    e[tot] &#x3D; &#123;u, v, w, head[u]&#125;;    head[u] &#x3D; tot++;    e[tot] &#x3D; &#123;v, u, 0, head[v]&#125;;    head[v] &#x3D; tot++;&#125;int h[N], n, m, s, t;bool bfs() &#123;        memset(h, 0, sizeof h);    memcpy(cur, head, sizeof cur);        queue&lt;int&gt; q;    q.push(s);    h[s] &#x3D; 1;        while(!q.empty()) &#123;        int u &#x3D; q.front();        q.pop();        for(int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;            int v &#x3D; e[i].v;            if(e[i].w and h[v] &#x3D;&#x3D; 0) &#123;                h[v] &#x3D; h[u] + 1;                if(v &#x3D;&#x3D; t) return true;                q.push(v);            &#125;        &#125;    &#125;        return false;&#125;int dfs(int u, int low) &#123;    if(u &#x3D;&#x3D; t) return low;    int w &#x3D; low;    for(int i &#x3D; cur[u]; i !&#x3D; -1; i &#x3D; e[i].next, cur[u] &#x3D; i) &#123;        int v &#x3D; e[i].v;        if(e[i].w and h[v] &#x3D;&#x3D; h[u] + 1) &#123;            int f &#x3D; dfs(v, min(w, e[i].w));            if(f &#x3D;&#x3D; 0) h[v] &#x3D; 0;            e[i].w -&#x3D; f;            e[i^1].w +&#x3D; f;            w -&#x3D; f;            if(w &#x3D;&#x3D; 0) break;        &#125;    &#125;    return low - w;&#125;int maxflow &#x3D; 0, sum &#x3D; 0;void dinic() &#123;    int flow;    while(bfs()) while(flow &#x3D; dfs(s, INF)) maxflow +&#x3D; flow;&#125;int main() &#123;        &#x2F;&#x2F;freopen(&quot;shut2.in&quot;, &quot;r&quot;, stdin);        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);        memset(head, -1, sizeof head);    s &#x3D; 0, t &#x3D; n+m+1;    for(int i&#x3D;1, w; i&lt;&#x3D;m; ++i) &#123;                scanf(&quot;%d&quot;, &amp;w);        add(s, i, w);        sum +&#x3D; w;                memset(tools, &#39;\0&#39;, sizeof tools);         cin.getline(tools, 10000);        int ulen &#x3D; 0, tool;        while(sscanf(tools + ulen, &quot;%d&quot;, &amp;tool) &#x3D;&#x3D; 1) &#123;            add(i, tool + m, INF);            if(tool &#x3D;&#x3D; 0) ulen++;            else &#123;                while(tool) &#123;                    tool &#x2F;&#x3D; 10;                    ulen++;                &#125;            &#125;            ulen++;        &#125;    &#125;        for(int i&#x3D;1, w; i&lt;&#x3D;n; ++i) &#123;        scanf(&quot;%d&quot;, &amp;w);        add(i+m, t, w);    &#125;        dinic();        for(int i&#x3D;1; i&lt;&#x3D;m; ++i) if(h[i]) printf(&quot;%d &quot;, i);    printf(&quot;\n&quot;);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) if(h[i+m]) printf(&quot;%d &quot;, i);    printf(&quot;\n&quot;);        printf(&quot;%d\n&quot;, sum - maxflow);        return 0;&#125;</code></pre><h2 id="全局最小割"><a href="#全局最小割" class="headerlink" title="全局最小割"></a>全局最小割</h2><p>暂时留坑，可以先参考<a href="https://blog.csdn.net/ddelphine/article/details/77935670">这篇文章</a>。</p><h3 id="Code-POJ-2914-未优化版"><a href="#Code-POJ-2914-未优化版" class="headerlink" title="Code (POJ 2914, 未优化版)"></a>Code (POJ 2914, 未优化版)</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 550;int g[N][N];int dis[N];bool flag[N], vis[N];int n, m, s, t;int main() &#123;        while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) !&#x3D; EOF) &#123;                memset(g, 0, sizeof g);                for(int i&#x3D;1, a, b, c; i&lt;&#x3D;m; ++i) &#123;            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            ++a, ++b;            g[a][b] +&#x3D; c; g[b][a] +&#x3D; c;         &#125;                int ans &#x3D; 0x3f3f3f3f;        memset(flag, false, sizeof flag);                for(int o&#x3D;1; o&lt;n; ++o) &#123;                        s &#x3D; t &#x3D; 0;                        memset(vis, false, sizeof vis);            memset(dis, 0, sizeof dis);                         for(int p&#x3D;1; p&lt;&#x3D;n; ++p) &#123;                                int v &#x3D; -1;                for(int i&#x3D;1; i&lt;&#x3D;n; ++i)                     if(!flag[i] and !vis[i] and (v &#x3D;&#x3D; -1 or dis[v] &lt; dis[i]))                        v &#x3D; i;                if(v &#x3D;&#x3D; -1) break;                                vis[v] &#x3D; true;                                s&#x3D;t, t&#x3D;v;                for(int i&#x3D;1; i&lt;&#x3D;n; ++i)                     if(!flag[i] and !vis[i])                         dis[i] +&#x3D; g[t][i];            &#125;                        flag[t] &#x3D; true;            ans &#x3D; min(ans, dis[t]);                        if(ans &#x3D;&#x3D; 0) break;                        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;                if(flag[i]) continue;                g[s][i] +&#x3D; g[t][i];                g[i][s] +&#x3D; g[i][t];            &#125;                        &#125;                printf(&quot;%d\n&quot;, ans);    &#125;         return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF387D</title>
      <link href="cf387d/"/>
      <url>cf387d/</url>
      
        <content type="html"><![CDATA[<h1 id="CF387D"><a href="#CF387D" class="headerlink" title="CF387D"></a>CF387D</h1><h2 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h2><p>操作最少的次数，构成有趣图，注意无重边，有向边。</p><ul><li>操作分为加边和删边。</li><li>有趣图定义<ul><li>有一个中心，满足此点有自环，且与其他结点有双向边。</li><li>除中心点外的结点，满足出度 = 入度 = 2。</li></ul></li></ul><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>1、仔细分析有趣图的定义，发现如下性质：</p><ul><li>中心的边数为 $(n-1)\times 2+1$，也就是它与其他结点要有双向边再加自己的一个自环，无重边所以构造中心点时不可能做删除操作，只能加边或不操作。</li><li>其他结点的出入度为 2，排除掉与中心点连接的双向边，其点的度一定为一进一出。</li></ul><p>2、如何判断结点的度满足一进一出。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/cf387d1.png"></p><p>图一，图二都是满足结点度一进一出。所以 $n$ 个结点需要 $n$ 条相连边（首尾）。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/cf387d2.png"></p><p>图三不满足，<b>只有两条相连边 $(e_1,e_2)$ 或者选择 $(e_1,e_3)$ 即有用边,还需要添加 $n-2$ 边有用边，同时还要减掉 1 条边，即总边数减去有用边，也就是要删除的无用边。</b></p><blockquote><p>方法1：拆点，一个点拆为进点和出点，建立二分图。</p><p>​    <img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/cf387d3.png"></p><p>左边的点求匹配，最大匹配就是有用的边。</p><p>方法2：直接将图看成二分图，利用有向边每个点都求匹配。</p></blockquote><p>3、枚举每个点做中心点。</p><ul><li><p>中心点 V，计算维护中心需要的边 $(n-1)\times 2+1-\sum{V发出的边}$</p></li><li><p>删除 V 点，也就是包含相应的边</p></li><li><p>剩下的图，计算最大匹配，满足一进一出的边数需要的操作（添加边 + 删除边）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分图 </tag>
            
            <tag> 匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匹配：模板</title>
      <link href="match-template/"/>
      <url>match-template/</url>
      
        <content type="html"><![CDATA[<h1 id="匹配：模板"><a href="#匹配：模板" class="headerlink" title="匹配：模板"></a>匹配：模板</h1><h2 id="UOJ78-二分图最大匹配（DFS-KM）"><a href="#UOJ78-二分图最大匹配（DFS-KM）" class="headerlink" title="UOJ78 二分图最大匹配（DFS - KM）"></a>UOJ78 二分图最大匹配（DFS - KM）</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 550;int match[N], g[N][N], vis[N], link[N];int n, m, e, tag, ans &#x3D; 0;bool dfs(int u) &#123;        for(int v&#x3D;1; v&lt;&#x3D;m; ++v) &#123;        if(!g[u][v] or vis[v] &#x3D;&#x3D; tag) continue;        vis[v] &#x3D; tag;        if(!match[v] or dfs(match[v])) &#123;            match[v] &#x3D; u;            return true;        &#125;    &#125;    return false;&#125;int main() &#123;        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;e);    for(int i&#x3D;1, u, v; i&lt;&#x3D;e; ++i) &#123;        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        g[u][v] &#x3D; true;    &#125;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        tag &#x3D; i;        if(dfs(i)) ++ans;    &#125;        printf(&quot;%d\n&quot;, ans);    for(int i&#x3D;1; i&lt;&#x3D;m; ++i) link[match[i]] &#x3D; i;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) printf(&quot;%d &quot;, link[i]);        return 0;&#125;</code></pre><h2 id="UOJ79-一般图最大匹配（带花树）"><a href="#UOJ79-一般图最大匹配（带花树）" class="headerlink" title="UOJ79 一般图最大匹配（带花树）"></a>UOJ79 一般图最大匹配（带花树）</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 550;int fa[N], match[N], pre[N], vis[N];int tag &#x3D; 0, n, m, ans &#x3D; 0;int flag[N];bool g[N][N];queue&lt;int&gt; q;void clear(queue&lt;int&gt; &amp;q) &#123;    queue&lt;int&gt; empty;    swap(q, empty);&#125;int belong(int u) &#123;    return fa[u] &#x3D;&#x3D; u ? u : fa[u] &#x3D; belong(fa[u]);&#125;void path(int u) &#123;    while(u) &#123;        int v &#x3D; match[pre[u]];        match[u] &#x3D; pre[u];        match[pre[u]] &#x3D; u;        u &#x3D; v;    &#125;&#125;int lca(int u, int v) &#123;    ++tag;    u &#x3D; belong(u);    v &#x3D; belong(v);    while(vis[u] !&#x3D; tag) &#123;        vis[u] &#x3D; tag;        u &#x3D; belong(pre[match[u]]);        if(v) swap(u, v);    &#125;    return u;&#125;void connect(int u, int v, int root) &#123;    while(belong(u) !&#x3D; root) &#123;        pre[u] &#x3D; v;        v &#x3D; match[u];        if(flag[v] &#x3D;&#x3D; 2) &#123;            q.push(v);            flag[v] &#x3D; 1;        &#125;        if(belong(u) &#x3D;&#x3D; u) fa[u] &#x3D; root;        if(belong(v) &#x3D;&#x3D; v) fa[v] &#x3D; root;        u &#x3D; pre[v];    &#125;&#125;bool bfs(int u) &#123;        memset(flag, 0, sizeof flag);    memset(pre, 0, sizeof pre);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) fa[i] &#x3D; i;        clear(q);    q.push(u);    flag[u] &#x3D; 1;        while(!q.empty()) &#123;        u &#x3D; q.front();        q.pop();        for(int v&#x3D;1; v&lt;&#x3D;n; ++v) &#123;            if(!g[u][v]) continue;            if(flag[v] &#x3D;&#x3D; 0) &#123;                pre[v] &#x3D; u;                if(match[v] &#x3D;&#x3D; 0) &#123;                    path(v);                    return true;                &#125;                q.push(match[v]);                flag[v] &#x3D; 2;                flag[match[v]] &#x3D; 1;            &#125; else &#123;                if(flag[v] &#x3D;&#x3D; 2) continue;                if(belong(u) &#x3D;&#x3D; belong(v)) continue;                int root &#x3D; lca(u, v);                connect(u, v, root);                connect(v, u, root);            &#125;        &#125;    &#125;    return false;&#125;int main() &#123;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(int i&#x3D;1, u, v; i&lt;&#x3D;m; ++i) &#123;        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        g[u][v] &#x3D; g[v][u] &#x3D; true;    &#125;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i)         if(match[i] &#x3D;&#x3D; 0 and bfs(i)) ++ans;        printf(&quot;%d\n&quot;, ans);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) printf(&quot;%d &quot;, match[i]);         return 0;&#125;</code></pre><h2 id="UOJ80-二分图最大权匹配（BFS-KM）"><a href="#UOJ80-二分图最大权匹配（BFS-KM）" class="headerlink" title="UOJ80 二分图最大权匹配（BFS - KM）"></a>UOJ80 二分图最大权匹配（BFS - KM）</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N &#x3D; 440;const LL INF &#x3D; 0x3f3f3f3f3f3f3f3f;bool vis[N];int pre[N], link[N], res[N];int n, m, e;LL g[N][N], lx[N], ly[N], d[N], ans &#x3D; 0;void bfs(int k) &#123;        int x, y &#x3D; 0;    LL min1 &#x3D; INF, delta;    memset(vis, false, sizeof vis);    memset(pre, 0, sizeof pre);    memset(d, 0x3f, sizeof d);    link[y] &#x3D; k;        do &#123;        x &#x3D; link[y], delta &#x3D; INF, vis[y] &#x3D; true;        for(int i&#x3D;1; i&lt;&#x3D;m; ++i) &#123;            if(!vis[i]) &#123;                if(d[i] &gt; lx[x] + ly[i] - g[x][i]) &#123;                    d[i] &#x3D; lx[x] + ly[i] - g[x][i];                    pre[i] &#x3D; y;                &#125;                if(delta &gt; d[i]) delta &#x3D; d[i], min1 &#x3D; i;            &#125;        &#125;        for(int i&#x3D;0; i&lt;&#x3D;m; ++i)        if(vis[i]) lx[link[i]] -&#x3D; delta, ly[i] +&#x3D; delta;        else d[i] -&#x3D; delta;        y &#x3D; min1;    &#125; while(link[y]);    while(y) link[y] &#x3D; link[pre[y]], y &#x3D; pre[y];&#125;int main() &#123;        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;e);    m &#x3D; max(n, m);    for(int i&#x3D;1; i&lt;&#x3D;e; ++i) &#123;        int u, v; LL w;        scanf(&quot;%d%d%lld&quot;, &amp;u, &amp;v, &amp;w);        g[u][v] &#x3D; w;        lx[u] &#x3D; max(lx[u], w);    &#125;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) bfs(i);        for(int i&#x3D;1; i&lt;&#x3D;m; ++i) &#123;        if(!g[link[i]][i]) continue;        ans +&#x3D; g[link[i]][i];        res[link[i]] &#x3D; i;    &#125;    printf(&quot;%lld\n&quot;, ans);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) printf(&quot;%d &quot;, res[i]);        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分图 </tag>
            
            <tag> 匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沼</title>
      <link href="numa/"/>
      <url>numa/</url>
      
        <content type="html"><![CDATA[<h2 id="沼"><a href="#沼" class="headerlink" title="沼"></a>沼</h2><p>&emsp;&emsp;沼底的尽头，是一片覆压百万里的金色宫殿。大殿的外墙上，布满了交通错落的铭文，似是在昭示着什么。</p><p>&emsp;&emsp;一天，一个女孩闯入了这里。一阵和煦的金光顿时笼罩了她；俄而散去，四下无痕。</p><p>&emsp;&emsp;没过了几个小时，又进来了一个男孩，像是在呼唤着什么，——。金光一如既往地扩散开来； 一道道刻痕爆裂而开，流转着金黄的光珠，跳动着淡蓝的光焰——</p><p>&emsp;&emsp;但一切终又重归了平静。唯一不同的是男孩进入的那座殿堂，蒙上了雪一般的白色，白得灼痛了双眼——</p><p>&emsp;&emsp;殿中央，一个男孩旁边躺着一个女孩。在渐渐模糊的视野里，他们站起了身，向沼底的深处走去。突然地，一座一座的宫殿轰然倒下，杳然无踪，连瓦砾都浸没在夕阳里。</p><hr><p>&emsp;&emsp;他们的面前是一片水原。             </p><p>&emsp;&emsp;“没有再向前的路了呢，”男孩道。 </p><p>&emsp;&emsp;“那⋯⋯要不就在这里？”女孩问道。</p><p>&emsp;&emsp;男孩没有回答。空无一物的海面上，反射着太阳的光辉。</p><p>&emsp;&emsp;“这里⋯⋯没有我能回去的地方了。” </p><p>&emsp;&emsp;女孩的心微微一颤。</p><p>&emsp;&emsp;黑云压了下来。男孩看向她的眼睛；在那双湛蓝的天空里，像是有两束晶莹的泪在燃烧。</p><p>&emsp;&emsp;“你回去吧，”男孩在岸边坐下。冰冷的寂静刺穿了黑暗。“你还有更重要的东西。” </p><p>&emsp;&emsp;“——那你呢？”</p><p>&emsp;&emsp;“我？……雨女无瓜。”</p><p>&emsp;&emsp;女孩再次担忧地看了他一眼，转过身去。五彩斑斓的黑洇染了苍穹，等男孩回过神来，已是孤身一人。</p><p>&emsp;&emsp;他向前迈了一步。一座巨浪打在他脚下，险些将他卷为齑粉。要是她还在这里的话，说不定已经被撕碎了呢，他想。</p><p>&emsp;&emsp;他轻轻咬了咬唇，刚挤出的笑容粉碎在脸上。他自知最多也就能到这里了，还是回去为好。</p><p>&emsp;&emsp;他拾起石子掷向水中；石子弹跳着沉了下去。</p><p>&emsp;&emsp;黑夜却还不急着到来。太阳迸发出血红的光芒，向西方吃力地转动着。</p><hr><p>&emsp;&emsp;男孩在水底见到了他的朋友。一只巨大的鲲。</p><p>&emsp;&emsp;“还要在这里待多久？”男孩试探着问道。</p><p>&emsp;&emsp;“多久？”鲲摇了摇尾巴，“我不知道。”</p><p>&emsp;&emsp;“……真的没打算离开嘛？”</p><p>&emsp;&emsp;“离开？离开幹什么？”鲲又摇了摇尾巴，脸上露出奇异的神色来。男孩平静地看向他。</p><p>&emsp;&emsp;“——没事了。”</p><p>&emsp;&emsp;男孩侧过头去，脸上始终没有浮现过可以称之为表情的东西。四下的水雾扩散开来，像狰狞的水母的触手一样，箍紧了沼底的天空。</p><p>&emsp;&emsp;自非亭午夜分，不见曦月。</p><hr><p>&emsp;&emsp;女孩坐在大殿的中央，看着周遭的残壁在烈火中熔释。火光给她的脸染成了金色；凤凰在她的脑畔上盘旋，就像穿行在无边的旷野，有着挣脱一切的力量。</p><hr><p>&emsp;&emsp; “如何？”她问道。</p><p>&emsp;&emsp;“还好吧，”他没有抬头，“就是还得再适应一点时间。需要重铸的事情太多了。”</p><p>&emsp;&emsp;“或许吧，”她附和道。</p><p>&emsp;&emsp;远处的蝉叫了起来。</p><p>&emsp;&emsp;男孩和她都在等待着什么。她的目光望向窗外：雪花从天中飘落，给葱茏的树叶抹上了一层白霜。</p><p>&emsp;&emsp;“抱歉了。” </p><p>&emsp;&emsp;男孩点了点头。</p><p>&emsp;&emsp; “⋯⋯去哪儿？” 男孩的声音微颤了一下。</p><p>&emsp;&emsp;她的瞳孔一缩。<b>若是重开一次，</b>她想，<b>这些话本不应该被说出来的。</b>她会不会……</p><p>&emsp;&emsp;“所以你是怎么知道的呢？”她定定地望向他。</p><p>&emsp;&emsp;四面的风静了下来。</p><hr><p>&emsp;&emsp;女孩回到了水原——or she expected so。一团团死掉的水嘶叫着从湖底的罅隙里鱼贯而出，取而代之的，是一条条岩浆的河；大地像饼干一样脆生生地从中间裂开，散落出无数如粉如沙的碎片，点缀在覆压百万里的橘红的海洋中，就像一口沸腾的锅，把晚霞也煮成了一般颜色。</p><p>&emsp;&emsp;她回过头：来时的路早已淹没在了递归的沼泽里。</p><p>&emsp;&emsp;女孩迟疑了一下，随即向着东方走去。月亮追赶着太阳，终于将它逼到了地平线下。</p><p>&emsp;&emsp;她一次也没有回头。</p><hr><div class="note success flat"><p>未完待续</p></div>]]></content>
      
      
      <categories>
          
          <category> 小说 &amp; 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流：模板</title>
      <link href="network-flow-template/"/>
      <url>network-flow-template/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流：模板"><a href="#网络流：模板" class="headerlink" title="网络流：模板"></a>网络流：模板</h1><h2 id="P3376-网络最大流（Dinic）"><a href="#P3376-网络最大流（Dinic）" class="headerlink" title="P3376 网络最大流（Dinic）"></a>P3376 网络最大流（Dinic）</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 11000, M &#x3D; 110000;const int INF &#x3D; 0x7fffffff;struct node &#123;    int u, v, w, next;&#125; e[M &lt;&lt; 1];int cur[N], h[N], tot;int dfn[N], ans, n, m, s, t;void add(int u, int v, int w) &#123;    e[tot] &#x3D; node(&#123;u, v, w, h[u]&#125;);    cur[u] &#x3D; h[u] &#x3D; tot++;&#125;bool bfs() &#123;    memset(dfn, 0, sizeof dfn);    queue&lt;int&gt; q;    dfn[s] &#x3D; 1;    q.push(s);    while(!q.empty()) &#123;        int u &#x3D; q.front();        q.pop();        for(int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;            int v &#x3D; e[i].v;            if(e[i].w and !dfn[v]) &#123;                dfn[v] &#x3D; dfn[u] + 1;                q.push(v);                if(v &#x3D;&#x3D; t) return true;            &#125;        &#125;    &#125;    return false;&#125;int dfs(int u, int low) &#123;    if(u &#x3D;&#x3D; t) return low;    int w &#x3D; low;    for(int i &#x3D; cur[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;        int v &#x3D; e[i].v;        cur[u] &#x3D; i;        if(e[i].w and dfn[v] &#x3D;&#x3D; dfn[u] + 1) &#123;            int f &#x3D; dfs(v, min(w, e[i].w));            e[i].w -&#x3D; f; e[i^1].w +&#x3D; f;            w -&#x3D; f;            if(!w) break;        &#125;    &#125;    return low - w;&#125;void dinic() &#123;    while(bfs()) &#123;        memcpy(cur, h, sizeof cur);        ans +&#x3D; dfs(s, INF);    &#125;&#125;int main() &#123;    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    memset(h, -1, sizeof h);    for(int i&#x3D;1, u, v, w; i&lt;&#x3D;m; ++i) &#123;        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        add(u, v, w);        add(v, u, 0);    &#125;    dinic();    printf(&quot;%d\n&quot;, ans);    return 0;&#125;</code></pre><h2 id="P3381-最小费用最大流（单路增广）"><a href="#P3381-最小费用最大流（单路增广）" class="headerlink" title="P3381 最小费用最大流（单路增广）"></a>P3381 最小费用最大流（单路增广）</h2><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlineconst int N &#x3D; 5500, M &#x3D; 55000, INF &#x3D; 0x3f3f3f3f;struct point &#123;    int u, val;    point(int _u &#x3D; 0, int _val &#x3D; 0): u(_u), val(_val) &#123;&#125;    bool operator &lt; (const point &amp;o) const &#123; return val &gt; o.val; &#125; &#125;;priority_queue &lt;point&gt; q;struct node &#123;    int u, v, w, f, next;    node() &#123;&#125;&#125; e[M &lt;&lt; 1];int head[N], tot &#x3D; 0;il void add(int u, int v, int w, int f) &#123;    e[tot].u &#x3D; u, e[tot].v &#x3D; v, e[tot].w &#x3D; w, e[tot].f &#x3D; f;    e[tot].next &#x3D; head[u]; head[u] &#x3D; tot++;&#125;int h[N], dis[N], flow[N], pre[N];int n, m, s, t;int maxflow &#x3D; 0, mincost &#x3D; 0;il bool dijkstra() &#123;    memset(dis, 0x3f, sizeof dis);    memset(flow, 0x3f, sizeof flow);    memset(pre, -1, sizeof pre);        dis[s] &#x3D; 0;    q.push(point(s, 0));    while (!q.empty()) &#123;        int u &#x3D; q.top().u, val &#x3D; q.top().val;        q.pop();        if (val &gt; dis[u]) continue;        for (int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;            int v &#x3D; e[i].v;            if (e[i].w and dis[v] &gt; dis[u] + e[i].f + h[u] - h[v]) &#123;                pre[v] &#x3D; i;                flow[v] &#x3D; min(flow[u], e[i].w);                dis[v] &#x3D; dis[u] + e[i].f + h[u] - h[v];                q.push(point(v, dis[v]));            &#125;        &#125;    &#125;    return dis[t] !&#x3D; INF;&#125;il void check() &#123;        for (int p &#x3D; pre[t]; p !&#x3D; -1; p &#x3D; pre[e[p].u]) &#123;        e[p].w -&#x3D; flow[t];        e[p^1].w +&#x3D; flow[t];    &#125;    maxflow +&#x3D; flow[t];    mincost +&#x3D; (dis[t] - h[s] + h[t]) * flow[t];        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) h[i] +&#x3D; dis[i];&#125;int main() &#123;        memset(head, -1, sizeof head);        scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    for(int i&#x3D;1, u, v, w, f; i&lt;&#x3D;m; ++i) &#123;        scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;w, &amp;f);        add(u, v, w, f);        add(v, u, 0, -f);    &#125;        while (dijkstra()) check();    printf(&quot;%d %d\n&quot;, maxflow, mincost);        return 0;&#125;</code></pre><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 5500, M &#x3D; 110000, INF &#x3D; 0x3f3f3f3f;struct node &#123;    int u, v, w, f, next;&#125; e[M];int h[N], tot &#x3D; 0;void add(int u, int v, int w, int f) &#123;    e[tot] &#x3D; &#123;u, v, w, f, h[u]&#125;;    h[u] &#x3D; tot++;&#125;int pre[N], flow[N], dis[N];bool vis[N];int n, m, s, t, maxflow, mincost;bool spfa() &#123;        memset(pre, -1, sizeof pre);    memset(vis, false, sizeof vis);    memset(dis, 0x3f, sizeof dis);    memset(flow, 0x3f, sizeof flow);        queue&lt;int&gt; q;    q.push(s);    vis[s] &#x3D; true;    dis[s] &#x3D; 0;        while(!q.empty()) &#123;        int u &#x3D; q.front();        q.pop();        vis[u] &#x3D; false;        for(int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;            int v &#x3D; e[i].v;            if(e[i].w and dis[v] &gt; dis[u] + e[i].f) &#123;                dis[v] &#x3D; dis[u] + e[i].f;                pre[v] &#x3D; i;                flow[v] &#x3D; min(flow[u], e[i].w);                if(!vis[v]) &#123;                    q.push(v);                    vis[v] &#x3D; true;                &#125;            &#125;        &#125;    &#125;        return dis[t] !&#x3D; INF;&#125;void check() &#123;    for(int p &#x3D; pre[t]; p !&#x3D; -1; p &#x3D; pre[e[p].u]) &#123;        e[p].w -&#x3D; flow[t];        e[p^1].w +&#x3D; flow[t];    &#125;        mincost +&#x3D; dis[t] * flow[t];    maxflow +&#x3D; flow[t];&#125;int main() &#123;        scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);        memset(h, -1, sizeof h);     for(int i&#x3D;1, u, v, w, f; i&lt;&#x3D;m; ++i) &#123;        scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;w, &amp;f);        add(u, v, w, f);        add(v, u, 0, -f);    &#125;        while(spfa()) check();        printf(&quot;%d %d\n&quot;, maxflow, mincost);    return 0;&#125;</code></pre><h2 id="LOJ115-无源汇有上下界可行流（超级源汇）"><a href="#LOJ115-无源汇有上下界可行流（超级源汇）" class="headerlink" title="LOJ115 无源汇有上下界可行流（超级源汇）"></a>LOJ115 无源汇有上下界可行流（超级源汇）</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlineconst int N &#x3D; 220, M &#x3D; 11000, INF &#x3D; 0x3f3f3f3f;struct node &#123;    int u, v, w, next;&#125; e[M * 6];int head[N], cur[N], tot &#x3D; 0;il void add(int u, int v, int w) &#123;    e[tot] &#x3D; (node) &#123;u, v, w, head[u]&#125;;    head[u] &#x3D; tot++;&#125;int h[N], n, m, ss, tt;il bool bfs() &#123; &#x2F;&#x2F;分层         memset(h, 0, sizeof h);    memcpy(cur, head, sizeof cur);    queue&lt;int&gt; q;    q.push(ss);    h[ss] &#x3D; 1;        while(!q.empty()) &#123;        int u &#x3D; q.front();        q.pop();        for(int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;            int v &#x3D; e[i].v;            if(e[i].w and !h[v]) &#123;                h[v] &#x3D; h[u] + 1;                if(v &#x3D;&#x3D; tt) return true;                q.push(v);            &#125;        &#125;    &#125;    return false;&#125;int dfs(int u, int low) &#123;    if(u &#x3D;&#x3D; tt) return low;    int w &#x3D; low;    for(int i &#x3D; cur[u]; i !&#x3D; -1; i &#x3D; e[i].next, cur[u] &#x3D; i) &#123;        int v &#x3D; e[i].v;        if(e[i].w and h[v] &#x3D;&#x3D; h[u] + 1) &#123;            int f &#x3D; dfs(v, min(w, e[i].w));            e[i].w -&#x3D; f;            e[i^1].w +&#x3D; f;            w -&#x3D; f;            if(!w) break;        &#125;    &#125;    return low - w;&#125;int tflow &#x3D; 0, sflow &#x3D; 0;il void dinic() &#123;        for(int i &#x3D; head[ss]; i !&#x3D; -1; i &#x3D; e[i].next)        sflow +&#x3D; e[i].w; &#x2F;&#x2F;出流量             while(bfs()) dfs(ss, INF);        for(int i &#x3D; head[tt]; i !&#x3D; -1; i &#x3D; e[i].next)         tflow +&#x3D; e[i].w; &#x2F;&#x2F;入流量         if(sflow &#x3D;&#x3D; tflow) &#123; &#x2F;&#x2F;满流         printf(&quot;YES\n&quot;);        for(int i&#x3D;0; i&lt;tot; i+&#x3D;6)             printf(&quot;%d\n&quot;, e[i+1].w + e[i+5].w); &#x2F;&#x2F;反边流量和     &#125; else printf(&quot;NO\n&quot;);    &#125;int main() &#123;        freopen(&quot;loj115.in&quot;, &quot;r&quot;, stdin);        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        memset(head, -1, sizeof head);    ss &#x3D; 0, tt &#x3D; n+1;    for(int i&#x3D;1, u, v, l, h; i&lt;&#x3D;m; ++i) &#123; &#x2F;&#x2F;建图         scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;l, &amp;h);        add(u, tt, l);        add(tt, u, 0);        add(ss, v, l);        add(v, ss, 0);        add(u, v, h-l);        add(v, u, 0);    &#125;        dinic();        return 0;&#125;</code></pre><h2 id="有源汇有上下界（转无源汇，然后断边）"><a href="#有源汇有上下界（转无源汇，然后断边）" class="headerlink" title="有源汇有上下界（转无源汇，然后断边）"></a>有源汇有上下界（转无源汇，然后断边）</h2><h3 id="最大流（顺流增广）"><a href="#最大流（顺流增广）" class="headerlink" title="最大流（顺流增广）"></a>最大流（顺流增广）</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 220, M &#x3D; 22000, INF &#x3D; 0x3f3f3f3f;struct node &#123;    int u, v, w, next;&#125; e[M];int head[N], cur[N], tot &#x3D; 0;void add(int u, int v, int w) &#123;    e[tot] &#x3D; (node) &#123;u, v, w, head[u]&#125;;    head[u] &#x3D; tot++;    e[tot] &#x3D; (node) &#123;v, u, 0, head[v]&#125;;    head[v] &#x3D; tot++;&#125;int h[N], in[N], n, m, s, t, ss, tt, sflow &#x3D; 0, tflow &#x3D; 0;bool bfs(int s, int t) &#123;        memset(h, 0, sizeof h);    memcpy(cur, head, sizeof cur);        queue&lt;int&gt; q;    q.push(s);    h[s] &#x3D; 1;        while(!q.empty()) &#123;        int u &#x3D; q.front();        q.pop();        for(int i &#x3D; head[u], v; i !&#x3D; -1; i &#x3D; e[i].next) &#123;            v &#x3D; e[i].v;            if(e[i].w and !h[v]) &#123;                h[v] &#x3D; h[u] + 1;                if(v &#x3D;&#x3D; t) return true;                q.push(v);             &#125;        &#125;    &#125;    return false;&#125;int dfs(int u, int low, int t) &#123;    if(u &#x3D;&#x3D; t) return low;        int w &#x3D; low;    for(int i &#x3D; cur[u], v; i !&#x3D; -1; i &#x3D; e[i].next, cur[u] &#x3D; i) &#123;        v &#x3D; e[i].v;        if(e[i].w and h[v] &#x3D;&#x3D; h[u] + 1) &#123;            int f &#x3D; dfs(v, min(w, e[i].w), t);            e[i].w -&#x3D; f;            e[i^1].w +&#x3D; f;            w -&#x3D; f;            if(!w) break;        &#125;    &#125;    return low - w;&#125;int main() &#123;        &#x2F;&#x2F;freopen(&quot;loj116.in&quot;, &quot;r&quot;, stdin);        scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);        ss &#x3D; 0, tt &#x3D; n+1;    memset(head, -1, sizeof head);    for(int i&#x3D;1, u, v, l, h; i&lt;&#x3D;m; ++i) &#123;        scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;l, &amp;h);        in[u] -&#x3D; l; in[v] +&#x3D; l;        add(u, v, h-l);    &#125;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        if(!in[i]);        else if(in[i] &gt; 0) &#123;            sflow +&#x3D; in[i];            add(ss, i, in[i]);        &#125; else &#123;            add(i, tt, -in[i]);        &#125;    &#125;        add(t, s, INF);        while(bfs(ss, tt)) tflow +&#x3D; dfs(ss, INF, tt);        if(sflow !&#x3D; tflow) &#123;        printf(&quot;please go home to sleep\n&quot;);        return 0;    &#125;        for(int i &#x3D; head[ss]; i !&#x3D; -1; i &#x3D; e[i].next)         e[i].w &#x3D; e[i^1].w &#x3D; 0;        for(int i &#x3D; head[tt]; i !&#x3D; -1; i &#x3D; e[i].next)        e[i].w &#x3D; e[i^1].w &#x3D; 0;        int sum &#x3D; e[--tot].w;    e[tot-1].w &#x3D; e[tot].w &#x3D; 0;        while(bfs(s, t)) sum +&#x3D; dfs(s, INF, t);        printf(&quot;%d\n&quot;, sum);            return 0;&#125;</code></pre><h3 id="最小流（逆流增广）"><a href="#最小流（逆流增广）" class="headerlink" title="最小流（逆流增广）"></a>最小流（逆流增广）</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 220, M &#x3D; 22000, INF &#x3D; 0x3f3f3f3f;struct node &#123;    int u, v, w, next;&#125; e[M];int head[N], cur[N], tot &#x3D; 0;void add(int u, int v, int w) &#123;    e[tot] &#x3D; (node) &#123;u, v, w, head[u]&#125;;    head[u] &#x3D; tot++;    e[tot] &#x3D; (node) &#123;v, u, 0, head[v]&#125;;    head[v] &#x3D; tot++;&#125;int h[N], in[N], n, m, s, t, ss, tt, sflow &#x3D; 0, tflow &#x3D; 0;bool bfs(int s, int t) &#123;        memset(h, 0, sizeof h);    memcpy(cur, head, sizeof cur);        queue&lt;int&gt; q;    q.push(s);    h[s] &#x3D; 1;        while(!q.empty()) &#123;        int u &#x3D; q.front();        q.pop();        for(int i &#x3D; head[u], v; i !&#x3D; -1; i &#x3D; e[i].next) &#123;            v &#x3D; e[i].v;            if(e[i].w and !h[v]) &#123;                h[v] &#x3D; h[u] + 1;                if(v &#x3D;&#x3D; t) return true;                q.push(v);             &#125;        &#125;    &#125;    return false;&#125;int dfs(int u, int low, int t) &#123;    if(u &#x3D;&#x3D; t) return low;        int w &#x3D; low;    for(int i &#x3D; cur[u], v; i !&#x3D; -1; i &#x3D; e[i].next, cur[u] &#x3D; i) &#123;        v &#x3D; e[i].v;        if(e[i].w and h[v] &#x3D;&#x3D; h[u] + 1) &#123;            int f &#x3D; dfs(v, min(w, e[i].w), t);            e[i].w -&#x3D; f;            e[i^1].w +&#x3D; f;            w -&#x3D; f;            if(!w) break;        &#125;    &#125;    return low - w;&#125;int main() &#123;        &#x2F;&#x2F;freopen(&quot;loj116.in&quot;, &quot;r&quot;, stdin);        scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);        ss &#x3D; 0, tt &#x3D; n+1;    memset(head, -1, sizeof head);    for(int i&#x3D;1, u, v, l, h; i&lt;&#x3D;m; ++i) &#123;        scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;l, &amp;h);        in[u] -&#x3D; l; in[v] +&#x3D; l;        add(u, v, h-l);    &#125;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        if(!in[i]);        else if(in[i] &gt; 0) &#123;            sflow +&#x3D; in[i];            add(ss, i, in[i]);        &#125; else &#123;            add(i, tt, -in[i]);        &#125;    &#125;        add(t, s, INF);        while(bfs(ss, tt)) tflow +&#x3D; dfs(ss, INF, tt);        if(sflow !&#x3D; tflow) &#123;        printf(&quot;please go home to sleep\n&quot;);        return 0;    &#125;        for(int i &#x3D; head[ss]; i !&#x3D; -1; i &#x3D; e[i].next)         e[i].w &#x3D; e[i^1].w &#x3D; 0;        for(int i &#x3D; head[tt]; i !&#x3D; -1; i &#x3D; e[i].next)        e[i].w &#x3D; e[i^1].w &#x3D; 0;        int sum &#x3D; e[--tot].w;    e[tot-1].w &#x3D; e[tot].w &#x3D; 0;        while(bfs(s, t)) sum +&#x3D; dfs(s, INF, t);        printf(&quot;%d\n&quot;, sum);            return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流：Dijkstra 求费用流</title>
      <link href="network-flow-dijkstra/"/>
      <url>network-flow-dijkstra/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流：Dijkstra-求费用流"><a href="#网络流：Dijkstra-求费用流" class="headerlink" title="网络流：Dijkstra 求费用流"></a>网络流：Dijkstra 求费用流</h1><p><strong>注：下文中的边权 $w$ 均表示费用 $f$。</strong></p><p>Dijkstra 不能求有负权边的最短路，所以我们可以对网络 $G$ 中的每一个点设置一个势函数 $h(u)$，以满足在与原图等价的新图中的边权非负。</p><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>在任意残留网络中的任意边 $(u,v)$ 都需要满足：<br>$$<br>w_{u, v}+h(u) - h(v)≥0<br>$$<br>令图 $G$ 的等价图为 $G’$，其对应的边 $(u,v)$ 的权值为<br>$$<br>w’<em>{u,v} = w</em>{u,v} + h(u) - h(v)<br>$$<br>因此，对于原图中的任意一条路径 $(u_1,u_2,\dots,u_k)$，它在 $G$ 中的权值为<br>$$<br>w_{u_1,u_2}+w_{u_2,u_3}+\dots+w_{u_{k-1},u_k}<br>$$<br>在 $G’$ 中的权值可化简为<br>$$<br>w_{u_1,u_2} + w_{u_2,u_3} + \dots + w_{u_{k-1}, u_k} + h(u_1)-h(u_k)<br>$$<br><strong>所以，在 $G’$ 求出的路径都可以对应到 $G$ 上。</strong></p><p>令 $d_{u}$ 为图 $G$ 中源点 $s$ 到点 $u$ 的最短路径，图 $G’$ 中为 $d’_{u}$，显然有</p><p>$$<br>d_{u,v} = d’_{u,v}-h(u)+h(v)<br>$$<br>所以我们只需要求 $G’$ 的最短路径，就能对应回原图的最短路径。</p><h2 id="势函数"><a href="#势函数" class="headerlink" title="势函数"></a>势函数</h2><h3 id="初值"><a href="#初值" class="headerlink" title="初值"></a>初值</h3><p>如果网络 $G$ 初始边权非负，则令 $h(u)=0$ ，否则可令 $h(u) = dis[u]$（用 SPFA 解决）。</p><p>证明略。</p><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><p>每次增广后，令 $h(u)=h(u)+dis[u]$ 即可。</p><p>证明：对于残余网络上的任意边 $(u,v)$，均有<br>$$<br>dis[u]+w_{u,v}+h(u)-h(v)≥dis[v]<br>$$<br>移项，得<br>$$<br>w_{u,v}+(h(u)+dis[u])-(h(v)+dis[v]) \geq 0<br>$$<br>证毕。</p><h2 id="P3381-［模板］最小费用最大流"><a href="#P3381-［模板］最小费用最大流" class="headerlink" title="P3381 ［模板］最小费用最大流"></a>P3381 ［模板］最小费用最大流</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlineconst int N &#x3D; 5500, M &#x3D; 55000, INF &#x3D; 0x3f3f3f3f;struct point &#123;    int u, val;    point(int _u &#x3D; 0, int _val &#x3D; 0): u(_u), val(_val) &#123;&#125;    bool operator &lt; (const point &amp;o) const &#123; return val &gt; o.val; &#125; &#125;;priority_queue &lt;point&gt; q;struct node &#123;    int u, v, w, f, next;    node() &#123;&#125;&#125; e[M &lt;&lt; 1];int head[N], tot &#x3D; 0;il void add(int u, int v, int w, int f) &#123;    e[tot].u &#x3D; u, e[tot].v &#x3D; v, e[tot].w &#x3D; w, e[tot].f &#x3D; f;    e[tot].next &#x3D; head[u]; head[u] &#x3D; tot++;&#125;int h[N], dis[N], flow[N], pre[N];int n, m, s, t;int maxflow &#x3D; 0, mincost &#x3D; 0;il bool dijkstra() &#123;    memset(dis, 0x3f, sizeof dis);    memset(flow, 0x3f, sizeof flow);    memset(pre, -1, sizeof pre);        dis[s] &#x3D; 0;    q.push(point(s, 0));    while (!q.empty()) &#123;        int u &#x3D; q.top().u, val &#x3D; q.top().val;        q.pop();        if (val &gt; dis[u]) continue;        for (int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;            int v &#x3D; e[i].v;            if (e[i].w and dis[v] &gt; dis[u] + e[i].f + h[u] - h[v]) &#123;                pre[v] &#x3D; i;                flow[v] &#x3D; min(flow[u], e[i].w);                dis[v] &#x3D; dis[u] + e[i].f + h[u] - h[v];                q.push(point(v, dis[v]));            &#125;        &#125;    &#125;    return dis[t] !&#x3D; INF;&#125;il void check() &#123;        for (int p &#x3D; pre[t]; p !&#x3D; -1; p &#x3D; pre[e[p].u]) &#123;        e[p].w -&#x3D; flow[t];        e[p^1].w +&#x3D; flow[t];    &#125;    maxflow +&#x3D; flow[t];    mincost +&#x3D; (dis[t] - h[s] + h[t]) * flow[t];        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) h[i] +&#x3D; dis[i];&#125;int main() &#123;        freopen(&quot;p3381.in&quot;, &quot;r&quot;, stdin);        memset(head, -1, sizeof head);        scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    for(int i&#x3D;1, u, v, w, f; i&lt;&#x3D;m; ++i) &#123;        scanf(&quot;%d%d%d%d&quot;, &amp;u, &amp;v, &amp;w, &amp;f);        add(u, v, w, f);        add(v, u, 0, -f);    &#125;        while (dijkstra()) check();    printf(&quot;%d %d\n&quot;, maxflow, mincost);        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流：消圈算法</title>
      <link href="network-flow-deloop/"/>
      <url>network-flow-deloop/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流：消圈算法"><a href="#网络流：消圈算法" class="headerlink" title="网络流：消圈算法"></a>网络流：消圈算法</h1><p><strong>注：下文中的权均表示费用。</strong></p><h2 id="消圈定理"><a href="#消圈定理" class="headerlink" title="消圈定理"></a>消圈定理</h2><p>在某个流 $f$ 中，如果其残余网络中没有负圈（剩余流量为 $0$ 的边视为不存在），那它一定是当前流量下的最小费用，<strong>否则一定不是。</strong></p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>假设一个网络，所有边的容量都是 $1$。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://blog.sengxian.com/images/clearcircle/p1.png" alt="img"></p><p>如果流量走上路的话，其残余网络（黑箭头）变为：</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://blog.sengxian.com/images/clearcircle/p2.png" alt="img"></p><p>因为上路的边的流量占满了，所以现在上路只有反边。</p><p>显然 $A \rightarrow C \rightarrow t \rightarrow B \rightarrow A$ 为负圈，沿此负圈增广（每条边的流量＋1），环上每个点的入流量仍然等于出流量（原流为可行流）。</p><p>流量在圈中增广，总的流量既没有增加，也没有减少，只不过是流量从费用更少的地方流过 （$A \rightarrow C \rightarrow t$），从费用大的地方退流而已（$t \rightarrow B \rightarrow A$），流过的流量和退掉的流量是相等的，<b>实质上只是将从 $A$ 流出的流量的方向改变，使得费用更小。</b></p><p>网络流的反边给了我们一个很好的反悔机制，使得我们可以对任意一个流 $f$，通过消负圈（可能不止一个），来得到它当前流量下的最小费用流。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://blog.sengxian.com/images/clearcircle/p3.png" alt="img"></p><p>可以看到，沿着负圈增广之后，已经没有负圈存在了，已经达到了当前流量下的最小费用流（也就是最小费用最大流）。所以只要有负圈，就可以增广达到更小费用。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>求最小费用最大流时，可以先跑出一条可行最大流，然后通过不断消圈调整出最小费用。</p><p>更广泛用于残余网络寻找更优解。</p><h2 id="POJ2175-Evacuation-Plan"><a href="#POJ2175-Evacuation-Plan" class="headerlink" title="POJ2175 Evacuation Plan"></a>POJ2175 Evacuation Plan</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>原题面很长。</p><p>给出已达到最大流的残余网络，求出其是否已达到最小费用，如果未达到则找出更优方案。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>消圈模板，建出网络后利用 SPFA，如果一个节点被更新了 $n$ 次则说明图中一定存在负环。题目中没有说必须是最优解，因此只要将负圈上的流量调整 $1$ 即可。</p><p><b>注意一个节点被更新 $n$ 次不代表其一定在负权圈内。</b>正确做法是从这个节点 $v$ 开始不断捯它的前驱，如果发现某个节点 $u$ 被访问了两遍，则说明 $u$ 一定在负权圈内，再根据 $u$ 去捯前驱调整负权圈。</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>下图中某些边费用有误，因此该图不能推出正解，仅用作示意图。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/2poj2175%E6%AE%8B%E7%95%99%E5%9B%BE0.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/3poj2175%E6%AE%8B%E7%95%99%E5%9B%BE1.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/4poj2175%E6%AE%8B%E7%95%99%E5%9B%BE2.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/5poj2175%E8%B4%9F%E6%9D%83%E5%9C%88%E6%B5%81%E9%87%8F.png"></p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/6poj2175%E6%B1%82%E8%B4%9F%E6%9D%83%E5%9C%88.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;#define il inlinetemplate &lt;typename T&gt; il T abs(T x) &#123; return x &gt; 0 ? x : -x; &#125;const int N &#x3D; 110, M &#x3D; N * N &lt;&lt; 1, INF &#x3D; 0x3f3f3f3f;struct coor &#123;    int x, y, z;&#125; a[N], b[N];struct node &#123;    int u, v, w, f, next;&#125; e[M];int h[N &lt;&lt; 1], tot &#x3D; 0;bool vis[N &lt;&lt; 1];int n, m, s, t;int cnt[N &lt;&lt; 1], pre[N &lt;&lt; 1];il void add(int u, int v, int w, int f) &#123;    e[tot] &#x3D; (node) &#123;u, v, w, f, h[u]&#125;;    h[u] &#x3D; tot++;&#125;int bp[N][N], dis[N &lt;&lt; 1], p[N][N], occ[N];deque&lt;int&gt; q;bool cyc[N &lt;&lt; 1];il void check(int v) &#123;        do &#123;        cyc[v] &#x3D; true;        v &#x3D; e[pre[v]].u;    &#125; while(!cyc[v]);        int u &#x3D; v;    do &#123;        --e[pre[v]].w;        ++e[pre[v]^1].w;        v &#x3D; e[pre[v]].u;    &#125; while(u !&#x3D; v);                            for(int i&#x3D;1; i&lt;&#x3D;m; ++i)         for(int j &#x3D; h[n+i]; j !&#x3D; -1; j &#x3D; e[j].next)             if(e[j].v !&#x3D; t) bp[e[j].v][i] &#x3D; e[j].w;                                    printf(&quot;SUBOPTIMAL\n&quot;);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        for(int j&#x3D;1; j&lt;&#x3D;m; ++j) printf(&quot;%d &quot;, bp[i][j]);        printf(&quot;\n&quot;);    &#125;&#125;int main() &#123;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i)         scanf(&quot;%d%d%d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z);        for(int i&#x3D;1; i&lt;&#x3D;m; ++i)         scanf(&quot;%d%d%d&quot;, &amp;b[i].x, &amp;b[i].y, &amp;b[i].z);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i)        for(int j&#x3D;1; j&lt;&#x3D;m; ++j)            scanf(&quot;%d&quot;, &amp;p[i][j]),            occ[j] +&#x3D; p[i][j];        memset(h, -1, sizeof h);    s &#x3D; 0, t &#x3D; n+m+1;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        add(s, i, a[i].z, 0);        add(i, s, 0, 0);     &#125;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        for(int j&#x3D;1; j&lt;&#x3D;m; ++j) &#123;            int f &#x3D; abs(a[i].x - b[j].x) + abs(a[i].y - b[j].y) + 1;            add(i, n+j, INF, f);            add(n+j, i, p[i][j], -f);        &#125;    &#125;        for(int i&#x3D;1; i&lt;&#x3D;m; ++i) &#123;        add(n+i, t, b[i].z - occ[i], 0);        add(t, n+i, occ[i], 0);    &#125;        memset(dis, 0x3f, sizeof dis);        q.push_front(s);    vis[s] &#x3D; true;    ++cnt[s];    dis[s] &#x3D; 0;        while(!q.empty()) &#123;        int u &#x3D; q.front();        q.pop_front();        vis[u] &#x3D; false;        for(int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; e[i].next) &#123;            int v &#x3D; e[i].v;            if(e[i].w and dis[v] &gt; dis[u] + e[i].f) &#123;                pre[v] &#x3D; i;                dis[v] &#x3D; dis[u] + e[i].f;                if(!vis[v]) &#123;                    if(!q.empty() and dis[v] &gt;&#x3D; dis[q.front()]) q.push_back(v);                    else q.push_front(v);                    vis[v] &#x3D; true;                    ++cnt[v];                    if(cnt[v] &#x3D;&#x3D; t+1) &#123;                        check(v);                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;    printf(&quot;OPTIMAL\n&quot;);        return 0;&#125;</code></pre><p>算法证明中的图片引自 <a href="https://blog.sengxian.com/algorithms/clearcircle">Sengxian’s Blog</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>陌上</title>
      <link href="mo-shang/"/>
      <url>mo-shang/</url>
      
        <content type="html"><![CDATA[<h2 id="陌上"><a href="#陌上" class="headerlink" title="陌上"></a>陌上</h2><div class="note default flat"><p>多少次咫尺之隔的希望</p><p>却终是目送着的离开</p></div><p>&emsp;&emsp;__最美好的时候__（）</p><p>&emsp;&emsp;</p><p>&emsp;&emsp;？</p><p>&emsp;&emsp;</p><p>&emsp;&emsp;多少次经意又不经意</p><p>&emsp;&emsp;&emsp;&emsp;自然而又矫情</p><p>&emsp;&emsp;踌躇在触手可及的门口</p><p>&emsp;&emsp;&emsp;&emsp;隔的是无限的冰凌</p><p>&emsp;&emsp;缓慢而痛彻心扉</p><p>&emsp;&emsp;&emsp;&emsp;冷漠而撕心裂肺</p><p>&emsp;&emsp;</p><p>&emsp;&emsp;就算你冷若冰霜</p><p>&emsp;&emsp;&emsp;&emsp;就算残存的桥被时间的流冲淡</p><p>&emsp;&emsp;&emsp;&emsp;就算寒冰封冻了每一处角落</p><p>&emsp;&emsp;水雾浸湿了他的眼</p><p>&emsp;&emsp;&emsp;&emsp;留下往生不灭的洇痕</p><p>&emsp;&emsp;我</p><p>&emsp;&emsp;&emsp;&emsp;命不由天</p><p>&emsp;&emsp;</p><p>&emsp;&emsp;就算悸动的心被死寂的水销毁</p><p>&emsp;&emsp;&emsp;&emsp;就算迟来的阳光等不到花开的日子</p><p>&emsp;&emsp;&emsp;&emsp;就算此时相望不相闻    </p><p>&emsp;&emsp;溱与洧</p><p>&emsp;&emsp;&emsp;&emsp;方涣涣兮</p><p>&emsp;&emsp;明天</p><p>&emsp;&emsp;&emsp;&emsp;</p><p>&emsp;&emsp;愿往来翕忽的鱼儿</p><p>&emsp;&emsp;&emsp;&emsp;离开涸辙的田野</p><p>&emsp;&emsp;愿熙熙攘攘的行人</p><p>&emsp;&emsp;&emsp;&emsp;离开郁孤台的障翳</p><p>&emsp;&emsp;愿逐月华</p><p>&emsp;&emsp;&emsp;&emsp;流照君</p><p>&emsp;&emsp;</p><p>&emsp;&emsp;纵使过往的种种想要钦定了未来</p><p>&emsp;&emsp;&emsp;&emsp;纵使层迭的细沙似已磨灭了你我</p><p>&emsp;&emsp;（不甘、仗剑、人）</p><p>&emsp;&emsp;斩的</p><p>&emsp;&emsp;&emsp;&emsp;就是命运</p><p>&emsp;&emsp;</p><p>&emsp;&emsp;纵使真的到达了最黑暗的时刻</p><p>&emsp;&emsp;&emsp;&emsp;纵使远方的洪流咆哮着向着未来</p><p>&emsp;&emsp;&emsp;&emsp;纵使湛蓝的天空里爱恨交盏</p><p>&emsp;&emsp;&emsp;&emsp;纵使</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;山无棱</p><p>&emsp;&emsp;</p><p>&emsp;&emsp;如果再相遇</p><p>&emsp;&emsp;我想</p><p>&emsp;&emsp;&emsp;&emsp;陪你一起&emsp;飞过彷徨</p><p>&emsp;&emsp;&emsp;&emsp;看最初的一道光</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;凤凰于飞&emsp;覆照殷红</p><p>&emsp;&emsp;夕阳</p>]]></content>
      
      
      <categories>
          
          <category> 小说 &amp; 随笔 </category>
          
          <category> 陌上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尺取法</title>
      <link href="ruler-method/"/>
      <url>ruler-method/</url>
      
        <content type="html"><![CDATA[<h1 id="尺取法"><a href="#尺取法" class="headerlink" title="尺取法"></a>尺取法</h1><p><strong>与单调队列相关</strong></p><p>要求在满足条件的情况下，长度越长，答案越好（下简称具有单调性）.</p><p>利用双指针 $l,r$ 及队列思想，对于同一个 $l$ 让 $r$ 尽可能延伸至最远，得到一个答案区间，$r$ 已到达最远后将与 $l$ 有关的信息弹出，对于多个答案区间找出最优解．</p><h2 id="HDU5178-Pairs"><a href="#HDU5178-Pairs" class="headerlink" title="HDU5178 Pairs"></a>HDU5178 Pairs</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>有 $n$ 个值 $x_1, x_2, \dots,x_n$，求使得 $|x_b-x_a|\leqslant k,a&lt;b$ 的数对 $(a,b)$ 的个数．</p><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><p>分析可知 $a&lt;b$ 这一条件只是确保无重复，次序其实对于最终答案没有影响．</p><p>考虑先对 $x$ 排序（因原题目有绝对值，无影响），for​ $l$ 尺取出最远的 $r$， 则 $(l,r]$  间的每个数均与 $l$ 构成合法数对．</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;algorithm&gt;const int N &#x3D; 110000;typedef long long LL;int T, n;LL k, x[N];int main() &#123;         freopen(&quot;hdu5178.in&quot;, &quot;r&quot;, stdin);         scanf(&quot;%d&quot;, &amp;T);         while(T--) &#123;                  scanf(&quot;%d%lld&quot;, &amp;n, &amp;k);                  for(int i&#x3D;1; i&lt;&#x3D;n; ++i)             scanf(&quot;%lld&quot;, x+i);                  std::sort(x+1, x+n+1);                  LL ans &#x3D; 0;        for(int l&#x3D;1, r&#x3D;2; l&lt;&#x3D;n; ++l) &#123;            for(; r &lt;&#x3D; n and x[r] - x[l] &lt;&#x3D; k; ++r);            ans +&#x3D; r - l - 1;        &#125;                 printf(&quot;%lld\n&quot;, ans);    &#125;         return 0;&#125;</code></pre><h2 id="HDU6119-小小粉丝度度熊"><a href="#HDU6119-小小粉丝度度熊" class="headerlink" title="HDU6119 小小粉丝度度熊"></a>HDU6119 小小粉丝度度熊</h2><p><strong>类似 CF1041D Glider</strong></p><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>给出 $n$ 个已签到的天数区间，$m$ 张补签卡，求可获得的最大连续签到时长。</p><h3 id="解-1"><a href="#解-1" class="headerlink" title="解"></a>解</h3><p>尺取模板。</p><p>天数区间可重叠，须进行合并。</p><p>需要注意的是，当已确定最长合法区间 $[l,r]$ 后（即下一个区间与 $r$ 的距离大于剩余的补签卡数量，连不上），应把剩余补签卡全部应用到 $r$ 之后的天数上得到更优解。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>边界条件较多。</p><p>$R$ 为已加入队列的最后一个区间，判断的是区间 $R+1$ 的合法性。</p><p>特判第一个区间，开始时 $sum$ 直接加上第一个已签到区间的长，使用 $0$ 张补签卡。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 110000;struct node &#123;    int l, r;&#125; a[N], b[N];bool flag[N];bool cmp(node a, node b) &#123; return a.l &lt; b.l; &#125;int n, m;int max(int a, int b) &#123; return a &gt; b ? a : b; &#125;int main() &#123;         freopen(&quot;hdu6119.in&quot;, &quot;r&quot;, stdin);         while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) !&#x3D; EOF) &#123;                  for(int i&#x3D;1; i&lt;&#x3D;n; ++i)             scanf(&quot;%d%d&quot;, &amp;b[i].l, &amp;b[i].r),            flag[i] &#x3D; false;                        sort(b+1, b+n+1, cmp);                  for(int i&#x3D;2; i&lt;&#x3D;n; ++i) &#123;            if(b[i-1].r &gt;&#x3D; b[i].l) &#123;                b[i].l &#x3D; b[i-1].l;                b[i].r &#x3D; max(b[i].r, b[i-1].r);                flag[i-1] &#x3D; true;            &#125;        &#125;                  int tot &#x3D; 0;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;            if(flag[i]) continue;            a[++tot].l &#x3D; b[i].l;            a[tot].r &#x3D; b[i].r;        &#125;                 int sum &#x3D; a[1].r - a[1].l + 1, f &#x3D; 0, ans &#x3D; 0;        for(int L &#x3D; 1, R &#x3D; 1; L &lt;&#x3D; tot; ++L) &#123;            for(; R + 1 &lt;&#x3D; tot and f + a[R+1].l - a[R].r - 1 &lt;&#x3D; m; ++R)                sum +&#x3D; a[R+1].r - a[R].r,                f +&#x3D; a[R+1].l - a[R].r - 1;            ans &#x3D; max(ans, sum + m - f);            sum -&#x3D; a[L+1].l - a[L].l;            f -&#x3D; a[L+1].l - a[L].r - 1;        &#125;                 printf(&quot;%d\n&quot;, ans);    &#125;        return 0;&#125;</code></pre><h2 id="HDU1937-Finding-Seats"><a href="#HDU1937-Finding-Seats" class="headerlink" title="HDU1937 Finding Seats"></a>HDU1937 Finding Seats</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p>电影院有 $R$ 行 $C$ 列，用 <code>&#39;.&#39;</code> 表示空座，<code>&#39;X&#39;</code> 表示不可选。</p><p>要求选择至少 $K$ 个空座位 $(x_i, y_i)$，使得<br>$$<br>(\max x_i -\min x_i)\cdot(\max y_i -\min y_i),1\leqslant i \leqslant K<br>$$<br>最小。</p><h3 id="解-2"><a href="#解-2" class="headerlink" title="解"></a>解</h3><p>二维尺取。</p><p>枚举题目所求长方形的上下界，尺取求出左右最短距离。用二维前缀和简化空位查找。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 330;int row, c, k;char str[N];int s[N][N];int query(int x1, int y1, int x2, int y2) &#123;    return s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];&#125;int main() &#123;         freopen(&quot;hdu1937.in&quot;, &quot;r&quot;, stdin);         while(true) &#123;                 scanf(&quot;%d%d%d&quot;, &amp;row, &amp;c, &amp;k);        if(row &#x3D;&#x3D; 0 and c &#x3D;&#x3D; 0 and k &#x3D;&#x3D; 0)            break;                  for(int i&#x3D;1; i&lt;&#x3D;row; ++i) &#123;            scanf(&quot;%s&quot;, str+1);            int sum &#x3D; 0;            for(int j&#x3D;1; j&lt;&#x3D;c; ++j) &#123;                sum +&#x3D; (str[j] &#x3D;&#x3D; &#39;.&#39; ? 1 : 0);                s[i][j] &#x3D; s[i-1][j] + sum;            &#125;        &#125;                 int ans &#x3D; 0x7fffffff;        for(int up &#x3D; 1; up &lt;&#x3D; row; ++up) &#123;            for(int down &#x3D; up; down &lt;&#x3D; row; ++down) &#123;                for(int l&#x3D;1, r&#x3D;1; l&lt;&#x3D;c; ++l) &#123;                    for(; r&lt;&#x3D;c; ++r) &#123;                        if(query(up, l, down, r) &gt;&#x3D; k) &#123;                            ans &#x3D; min(ans, (down - up + 1) * (r - l + 1));                            break;                         &#125;                    &#125;                &#125;            &#125;        &#125;                  printf(&quot;%d\n&quot;, ans);    &#125;         return 0;&#125;</code></pre><h2 id="HDU5358-First-One"><a href="#HDU5358-First-One" class="headerlink" title="HDU5358 First One"></a>HDU5358 First One</h2><h3 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h3><p>有一数列 $a_1, a_2, \dots, a_n$，求<br>$$<br>\sum_{i=1}^{n} \sum_{j=i}^{n} (i + j)(\lfloor \log_2 \sum_{k=i}^{j} a_k \rfloor + 1)<br>$$<br>的值。特别地，$\log_20=0$。</p><h3 id="解-3"><a href="#解-3" class="headerlink" title="解"></a>解</h3><p>观察上式，对于 $\lfloor\log\rfloor$ 来说，它的一个值可对应很多个真数，考虑分块。</p><p>枚举 $\lfloor \log_2 \sum_{k=i}^{j} a_k \rfloor$ 的每一个值（1~34）。</p><p>令<br>$$<br>v =\lfloor \log_2 \sum_{k=i}^{j} a_k \rfloor<br>$$</p><p>$$<br>sum = \sum_{k=i}^{j}a_k<br>$$</p><p>则<br>$$<br>sum \in [2^{v-1},2^v)<br>$$<br>用尺取求出部分和在此范围的区段 $[i,j]$，求出结果加入计数器。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 110000;typedef long long LL;LL cl[40], a[N], s[N];int T, n;int main() &#123;         freopen(&quot;hdu5358.in&quot;, &quot;r&quot;, stdin);         cl[0] &#x3D; -1, cl[1] &#x3D; 1;    for(int i&#x3D;2; i&lt;&#x3D;34; ++i) cl[i] &#x3D; ((cl[i-1] + 1) &lt;&lt; 1LL) - 1;         scanf(&quot;%d&quot;, &amp;T);    while(T--) &#123;        scanf(&quot;%d&quot;, &amp;n);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) scanf(&quot;%lld&quot;, a+i);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) s[i] &#x3D; s[i-1] + a[i];                 LL ans &#x3D; 0;        for(LL k&#x3D;1; k&lt;&#x3D;34; ++k) &#123;            LL l &#x3D; 0, r &#x3D; 0;            for(LL i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;                for(l &#x3D; max(l, i); l &lt;&#x3D; n and s[l] - s[i-1] &lt;&#x3D; cl[k-1]; ++l);                for(r &#x3D; max(l, r); r &lt;&#x3D; n and s[r] - s[i-1] &lt;&#x3D; cl[k]; ++r);                ans +&#x3D; k * (i * (r-l) + (l+r-1) * (r-l) &#x2F; 2);            &#125;        &#125;        printf(&quot;%lld\n&quot;, ans);    &#125;         return 0;&#125;</code></pre><h2 id="HDU6103-Kirinriki"><a href="#HDU6103-Kirinriki" class="headerlink" title="HDU6103 Kirinriki"></a>HDU6103 Kirinriki</h2><h3 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h3><p>有两字符串 $A,B$（从 $1$ 编号），长度均为 $n$，定义<br>$$<br>dis(A,B) = \sum_{i=1}^n|A_i-B_{n-i}|<br>$$<br>字符之差定义为其 ASCII 码的差。</p><p>对于一字符串 $S$，找出它的两个不重叠连续子串，他们的 $dis$ 不大于 $m$，求最长合法子串长度。</p><h3 id="解-4"><a href="#解-4" class="headerlink" title="解"></a>解</h3><p>寻找单调性，易得<br>$$<br>\forall S’ \subseteq S,T’\subseteq T:dis(S’,T’)\leqslant dis(S,T)<br>$$<br>因此子串越长越好。</p><p>又$\because$ $\forall$ 两个合法子串，其必关于母串的某一位置（或某两位置之间）对称，考虑枚举这一中心点，分上面的两种情况。</p><p>注意到对于每个子串，其长度越大越好，同时又有约束上界，可对称尺取。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int abs(int x) &#123;    return x &gt; 0 ? x : -x; &#125;int max(int a, int b) &#123;    return a &gt; b ? a : b;&#125;int T, n, m;char s[22000];int main() &#123;         freopen(&quot;hdu6103.in&quot;, &quot;r&quot;, stdin);         scanf(&quot;%d&quot;, &amp;T);         while(T--) &#123;        scanf(&quot;%d&quot;, &amp;m);        scanf(&quot;%s&quot;, s+1);        int n &#x3D; strlen(s+1), ans &#x3D; 0;                  for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;            int f &#x3D; 0;            for(int l1 &#x3D; i-1, r1 &#x3D; i-1, l2 &#x3D; i+1, r2 &#x3D; i+1; l1 &gt; 0 and l2 &lt;&#x3D; n; --l1, ++l2) &#123;                for(; r1 &gt; 0 and r2 &lt;&#x3D; n and f + abs(s[r1] - s[r2]) &lt;&#x3D; m; --r1, ++r2) f +&#x3D; abs(s[r1] - s[r2]);                ans &#x3D; max(ans, r2 - l2);                f -&#x3D; abs(s[l1] - s[l2]);             &#125;        &#125;                  for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;            int f &#x3D; 0;            for(int l1 &#x3D; i, r1 &#x3D; i, l2 &#x3D; i+1, r2 &#x3D; i+1; l1 &gt; 0 and l2 &lt;&#x3D; n; --l1, ++l2) &#123;                for(; r1 &gt; 0 and r2 &lt;&#x3D; n and f + abs(s[r1] - s[r2]) &lt;&#x3D; m; --r1, ++r2) f +&#x3D; abs(s[r1] - s[r2]);                ans &#x3D; max(ans, r2 - l2);                f -&#x3D; abs(s[l1] - s[l2]);            &#125;        &#125;                  printf(&quot;%d\n&quot;, ans);    &#125;          return 0;&#125;</code></pre><h2 id="POJ2739-Sum-of-Consecutive-Prime-Numbers"><a href="#POJ2739-Sum-of-Consecutive-Prime-Numbers" class="headerlink" title="POJ2739 Sum of Consecutive Prime Numbers"></a>POJ2739 Sum of Consecutive Prime Numbers</h2><p>尺取水题。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;cmath&gt;using namespace std;bool prime(int x) &#123;    if(x &lt; 2) return false;    int m &#x3D; int(sqrt(x));        for(int i&#x3D;2; i&lt;&#x3D;m; ++i)         if(x % i &#x3D;&#x3D; 0) return false;    return true;&#125;int x, p[11000];int main() &#123;        int tot &#x3D; 0;    for(int i&#x3D;1; i&lt;&#x3D;10000; ++i) &#123;        if(prime(i)) p[++tot] &#x3D; i;    &#125;        while(true) &#123;        scanf(&quot;%d&quot;, &amp;x);        if(x &#x3D;&#x3D; 0) break;        int f &#x3D; 0, ans &#x3D; 0;        for(int l&#x3D;1, r&#x3D;1; l&lt;&#x3D;tot; ++l) &#123;            for(; r &lt;&#x3D; tot and f + p[r] &lt;&#x3D; x; ++r) f +&#x3D; p[r];            if(f &#x3D;&#x3D; x) ++ans;            f -&#x3D; p[l];        &#125;        printf(&quot;%d\n&quot;, ans);    &#125;        return 0;&#125;</code></pre><h2 id="CF1198A-MP3"><a href="#CF1198A-MP3" class="headerlink" title="CF1198A MP3"></a>CF1198A MP3</h2><h3 id="题面-5"><a href="#题面-5" class="headerlink" title="题面"></a>题面</h3><p>给出 $n,I$。</p><p>$n$ - 数列 $a_1,a_2,…,a_n$</p><p>选定一个区间 $[l,r]$，并进行操作，使<br>$$<br>v_i =<br>\begin{cases}<br>l&amp;v_i&lt;l\<br>v_i&amp;l\leqslant v_i \leqslant r\<br>r&amp;v_i&gt;r<br>\end{cases}<br>$$<br>要求经过处理后，数列中不同的数的个数 $\leqslant 2^{\lfloor 8I/n\rfloor}$，且使数列中被更改的位置的总数最小，求这个最小值。</p><h3 id="解-5"><a href="#解-5" class="headerlink" title="解"></a>解</h3><p>原题面较长，需耐心看题。</p><p>可先将原数列排序并离散化，记下每种数的出现次数，用前缀和优化求和。因顺序已预先排好，直接尺取 $[l,r]$，使区间内的值最大化，用总数相减得出答案。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 440000; int a[N], b[N], cnt[N], s[N], n, I, t; int power(int x) &#123;    int ans &#x3D; 1, base &#x3D; 2;    for(; x; x &gt;&gt;&#x3D; 1) &#123;        if(x &amp; 1) ans *&#x3D; base;        if(ans &gt; t) return ans;        base *&#x3D; base;    &#125;    return ans;&#125; int main() &#123;        freopen(&quot;cf1198a.in&quot;, &quot;r&quot;, stdin);         scanf(&quot;%d%d&quot;, &amp;n, &amp;I);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) scanf(&quot;%d&quot;, a+i), b[i] &#x3D; a[i];        if(8*I &gt; n*((int)log2(n) + 1)) &#123;        printf(&quot;0\n&quot;);        return 0;    &#125;        sort(b+1, b+n+1);    t &#x3D; unique(b+1, b+n+1) - (b+1);        int K &#x3D; power(8*I&#x2F;n);        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;        int p &#x3D; lower_bound(b+1, b+t+1, a[i]) - b;        ++cnt[p];    &#125;        for(int i&#x3D;1; i&lt;&#x3D;t; ++i) s[i] &#x3D; s[i-1] + cnt[i];        int ans &#x3D; 0x7fffffff;    for(int l&#x3D;1, r; l&lt;&#x3D;t; ++l) &#123;        r &#x3D; min(l + K - 1, t);        ans &#x3D; min(ans, s[t] - (s[r] - s[l-1]));    &#125;        printf(&quot;%d\n&quot;, ans);        return 0;&#125;</code></pre><h2 id="CF180E-Cubes"><a href="#CF180E-Cubes" class="headerlink" title="CF180E Cubes"></a>CF180E Cubes</h2><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>现有一数列 $a_1,a_2,…,a_n (1\leqslant a_i \leqslant m)$（更准确地翻译的话，现有一排小方块，第 $i$ 个方块的颜色为 $a_i$），求在最多删去 $k$ 个位置的数后，所能获得的最长连续子段的长度，要求该子段中所有数均相同．</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li>可以不删数．</li><li>$1 \leqslant n \leqslant 2 \times 10^5$，$1 \leqslant m \leqslant 10^5$，$0 \leqslant k &lt;n$．</li><li>样例#1：删去 $5th$ 和 $6th$．</li><li>样例#2：删去 $4th$ 和 $7th$．</li><li>样例#3：不变．</li></ul><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>枚举每种颜色，这样问题就可被简化为对于每种颜色，求出其修改后的最长合法子段，可用尺取法求解。</p><p>尺取法与单调队列有关，应用范围比较小，要求原问题在满足条件的情况下，长度越长，答案越好。利用双指针 $l,r$ 及队列思想，对于同一个 $l$ 让 $r$ 尽可能延伸至最远，得到一个答案区间，$r$ 已到达最远后将与 $l$ 有关的信息弹出，对于多个答案区间找出最优解。</p><p>更详细的解释请看<a href="%5Bhttps://www.baidu.com/s?ie=UTF-8&wd=%E5%B0%BA%E5%8F%96%E6%B3%95%5D(https://www.baidu.com/s?ie=UTF-8&wd=%E5%B0%BA%E5%8F%96%E6%B3%95)">这里</a></p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><p>将原数列分块，对每种颜色建立链表，枚举时直接访问。</p><p>链表的每个节点存储该颜色块的左右端点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;const int N &#x3D; 220000, M &#x3D; 110000;struct node &#123;    int l, r, next;&#125; a[N];int tmp[M], n, m, k, h[M];int main() &#123;        freopen(&quot;cf180e.in&quot;, &quot;r&quot;, stdin);        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);        int f &#x3D; 0, tot &#x3D; 0, ans &#x3D; 0;    for(int i&#x3D;1, c; i&lt;&#x3D;n; ++i) &#123;        scanf(&quot;%d&quot;, &amp;c);        if(f &#x3D;&#x3D; c) a[tot].r &#x3D; i;        else &#123;            a[++tot] &#x3D; (node) &#123;i, i, c, 0&#125;;            if(h[x]) a[tmp[c]].next &#x3D; tmp[c] &#x3D; tot;            else h[x] &#x3D; tmp[x] &#x3D; tot;            f &#x3D; c;        &#125;    &#125;        for(int i&#x3D;1; i&lt;&#x3D;m; ++i) &#123;        if(h[i] &#x3D;&#x3D; 0) continue; &#x2F;&#x2F; 无该颜色        int L &#x3D; h[i], R &#x3D; h[i], f &#x3D; 0, sum &#x3D; a[h[i]].r - a[h[i]].l + 1;        for(; L; L &#x3D; a[L].next) &#123;            for(; a[R].next and f + a[a[R].next].l - a[R].r - 1 &lt;&#x3D; k; R &#x3D; a[R].next)                 f +&#x3D; a[a[R].next].l - a[R].r - 1,                 sum +&#x3D; a[a[R].next].r - a[a[R].next].l + 1;                ans &#x3D; max(ans, sum); &#x2F;&#x2F; 统计            sum -&#x3D; a[L].r - a[L].l + 1; &#x2F;&#x2F; 弹出            f -&#x3D; a[a[L].next].l - a[L].r - 1;        &#125;    &#125;        printf(&quot;%d\n&quot;, ans);        return 0;&#125; </code></pre><h2 id="CF939E-Maximize"><a href="#CF939E-Maximize" class="headerlink" title="CF939E Maximize!"></a>CF939E Maximize!</h2><h3 id="题面-6"><a href="#题面-6" class="headerlink" title="题面"></a>题面</h3><p>对于一个只包含正整数的 multiset $S$，你需要支持以下 $2$ 种操作：</p><ul><li>$1$ <ul><li>找出 $S$ 的一个子集 $s$，使 $max(s)-mean(s)$ 最大，并输出这个最大值。保留十位小数。</li></ul></li><li>$2$ $x$<ul><li>加入一个新数 $x$ 到 $S$ 中，保证加入的数是递增的。</li></ul></li></ul><h3 id="解-6"><a href="#解-6" class="headerlink" title="解"></a>解</h3><p>思维题。</p><p>$max$ 越大越好，$mean$ 越小越好。</p><p>结论一：子集 $s$ 中必包含 $\max S$。</p><p>结论二：$\forall x \in S, x\notin s,mean(s) &gt; x:mean(s) &lt; mean(s\cup{x})$​ 。</p><p>证明略。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><p><del>略丑</del>。</p><p>为防止 WA，特判了较小的情况，维护的也略微麻烦一点。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;const int N &#x3D; 550000;typedef double LF;int Q, s[N];int main() &#123;        freopen(&quot;cf939e.in&quot;, &quot;r&quot;, stdin);        int tot &#x3D; 0, f &#x3D; 0;    LF sum &#x3D; 0, lastans &#x3D; 0, lasttype &#x3D; 0;        scanf(&quot;%d&quot;, &amp;Q);        while(Q--) &#123;            int type;        scanf(&quot;%d&quot;, &amp;type);                if(type &#x3D;&#x3D; 1) &#123;            scanf(&quot;%d&quot;, &amp;s[++tot]);            lasttype &#x3D; type;        &#125;        else &#123;                        if(lasttype &#x3D;&#x3D; 2) &#123;                printf(&quot;%.10lf\n&quot;, lastans);                continue;            &#125;                        if(tot &#x3D;&#x3D; 1) &#123;                printf(&quot;%.10lf\n&quot;, (LF)0);                lastans &#x3D; 0;                lasttype &#x3D; 2;                continue;            &#125;                        if(tot &#x3D;&#x3D; 2) &#123;                lastans &#x3D; s[2] - (s[1] + s[2]) &#x2F; 2.0;                printf(&quot;%.10lf\n&quot;, lastans);                lasttype &#x3D; 2;                sum &#x3D; s[1], f &#x3D; 1;                continue;            &#125;                        for(int i&#x3D;f+1; i&lt;tot; ++i) &#123;                if((LF)(sum + s[tot]) &#x2F; i &gt; (LF)s[i]) f &#x3D; i, sum +&#x3D; s[i];                else break;             &#125;                        lastans &#x3D; s[tot] - (sum + s[tot]) &#x2F; (f+1);            printf(&quot;%.10lf\n&quot;, lastans);                        lasttype &#x3D; type;        &#125;    &#125;        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 尺取法 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列</title>
      <link href="monotonous-queue/"/>
      <url>monotonous-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>具有单调性的队列。当一新值准备入队时，须先<strong>从后向前</strong>，将对后来答案没有了影响的点弹出，再<strong>从前向后</strong>，将所有超出了统计范围的点弹出。对于大多数问题，求解过程中会锁定很多答案区间，在线求最值。</p><h2 id="P3088-拥挤的奶牛"><a href="#P3088-拥挤的奶牛" class="headerlink" title="P3088 拥挤的奶牛"></a>P3088 拥挤的奶牛</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>有 $N$ 头奶牛沿着一维的栅栏吃草，第 $i$ 头奶牛在目标点 $x_i$，它的身高是 $h_i$ 。当一头奶牛左边 $D$ 距离内而且右边 $D$ 距离内有身高至少是它的两倍的奶牛，它就会觉得拥挤。</p><p>请计算觉得拥挤的奶牛的数量。</p><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><p>（单调队列模板？）</p><p>当一奶牛将要入队时：</p><ul><li><strong>从后往前</strong>，将身高小于该奶牛的弹出（<code>--tail</code>），因为将要进队的奶牛更加靠后，影响范围一定更大，对答案的贡献也一定更大。</li><li><strong>从前往后</strong>，将与该奶牛距离已超过 $D$ 的奶牛弹出（<code>++head</code>）</li><li>将该奶牛入队。</li><li>与队头奶牛比较身高，若符合则打上标记，若左右两次统计均符合，则计入答案。</li></ul><p>每次统计的是该奶牛左侧的合法性，从后到前再做一遍就可以了。</p><p>按照以上规则就可以统计答案了。显然该队列一定为单调递降队列。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 55000;struct node &#123;    int x, h;&#125; a[N];int n, d, queue[N];bool l[N], r[N];bool cmp(node a, node b) &#123;    return a.x &lt; b.x;&#125;int main() &#123;        freopen(&quot;p3088.in&quot;, &quot;r&quot;, stdin);        scanf(&quot;%d%d&quot;, &amp;n, &amp;d);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i)         scanf(&quot;%d%d&quot;, &amp;a[i].x, &amp;a[i].h);        sort(a+1, a+n+1, cmp);        int head &#x3D; 0, tail &#x3D; 1;    queue[head] &#x3D; 1;        for(int i&#x3D;2; i&lt;&#x3D;n; ++i) &#123;        while(head &lt; tail and a[queue[tail-1]].h &lt;&#x3D; a[i].h) --tail;        queue[tail++] &#x3D; i;        while(head &lt; tail and a[i].x - a[queue[head]].x &gt; d) ++head;                if(a[queue[head]].h &gt;&#x3D; (a[i].h &lt;&lt; 1)) l[i] &#x3D; true;    &#125;        head &#x3D; 0, tail &#x3D; 1;    queue[head] &#x3D; n;        for(int i&#x3D;n-1; i&gt;&#x3D;1; --i) &#123;        while(head &lt; tail and a[queue[tail-1]].h &lt;&#x3D; a[i].h) --tail;        queue[tail++] &#x3D; i;        while(head &lt; tail and a[queue[head]].x - a[i].x &gt; d) ++head;                if(a[queue[head]].h &gt;&#x3D; (a[i].h &lt;&lt; 1)) r[i] &#x3D; true;    &#125;        int ans &#x3D; 0;    for(int i&#x3D;1; i&lt;&#x3D;n; ++i)         if(l[i] and r[i]) ++ans;            printf(&quot;%d\n&quot;, ans);        return 0;&#125;</code></pre><h2 id="P3522-Temperature"><a href="#P3522-Temperature" class="headerlink" title="P3522 Temperature"></a>P3522 Temperature</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>有 $n$ 个段，第 $i$ 个为 $[l_i, r_i]$，现要在几个连续的段中，每段中各取一个值，构成一序列，要求该序列不能下降，求序列的最大长度。</p><h3 id="解-1"><a href="#解-1" class="headerlink" title="解"></a>解</h3><p>以段的左端点维护单调序列。</p><p>当一新段将要入队时：</p><ul><li><strong>从后向前</strong>，将所有左点比新段的左点小的段弹出。</li><li><strong>从前向后</strong>，将所有<strong>右点</strong>比新段的<strong>左点</strong>小的段弹出。</li><li>统计答案：用当前位置减去<strong>队头的上一段的位置</strong><ul><li>$\because$ 队头的上一段已被弹出</li><li>$\therefore$ 从队头的上一段的下一段起（可能已被弹出）至当前位置均属于合法序列</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;const int N &#x3D; 1100000;int max(int a, int b) &#123; return a &gt; b ? a : b; &#125;int n, l[N], r[N], queue[N], ans &#x3D; -1;int main() &#123;        freopen(&quot;p3522.in&quot;, &quot;r&quot;, stdin);        scanf(&quot;%d&quot;, &amp;n);    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) scanf(&quot;%d%d&quot;, l+i, r+i);        int head &#x3D; 0, tail &#x3D; 1;    queue[head] &#x3D; 0;        for(int i&#x3D;1; i&lt;&#x3D;n; ++i) &#123;                while(head &lt; tail and l[i] &gt;&#x3D; l[queue[tail-1]]) --tail;        queue[tail++] &#x3D; i;                while(head &lt; tail and l[queue[head]] &gt; r[i]) ++head;                ans &#x3D; max(ans, i - queue[head-1]);            &#125;        printf(&quot;%d\n&quot;, ans);        return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About CODESTYLE</title>
      <link href="about-codestyle/"/>
      <url>about-codestyle/</url>
      
        <content type="html"><![CDATA[<h3 id="commit-命名规范"><a href="#commit-命名规范" class="headerlink" title="commit 命名规范"></a>commit 命名规范</h3><ul><li>feat: 一个新功能</li><li>fix: 一个 bug 修复</li><li>docs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE 等</li><li>style: 不影响代码逻辑的修改，比如空格、格式缩进、删除分号等</li><li>refactor: 代码重构</li><li>perf: 提升性能的改动</li><li>test: 增加或修改测试</li><li>chore: 改变构建流程、或者增加辅助工具、依赖库等</li></ul><h3 id="2020-04-05-修改："><a href="#2020-04-05-修改：" class="headerlink" title="2020.04.05 修改："></a>2020.04.05 修改：</h3><ul><li>2020.02 中的所有修改作废。</li></ul><h3 id="2020-02-修改："><a href="#2020-02-修改：" class="headerlink" title="2020.02 修改："></a>2020.02 修改：</h3><ul><li><p>最近喜欢用 <code>inline</code> 。</p></li><li><p>尽量避免强制类型转换。</p></li><li><p>使用构造函数。</p></li></ul><h3 id="2020-01-修改："><a href="#2020-01-修改：" class="headerlink" title="2020.01 修改："></a>2020.01 修改：</h3><ul><li><p>凡继承自 C 语言的库，均使用 <code>&lt;xxx.h&gt;</code> 而不是 <code>&lt;cxxx&gt;</code> 。</p></li><li><p>以下情况中，运算符前后<strong>一定</strong>不加空格：</p><ul><li><p><code>for</code> 循环括号内内容较短时（<strong><em>e.g.</em></strong> <code>for(int i=1; i&lt;=n; ++i)</code> ）</p></li><li><p>运算符前后关系较密切时</p></li></ul></li><li><p>以下情况中，运算符前后<strong>一般</strong>不加空格：</p><ul><li>变量名长度为 1 时</li></ul></li><li><p>以下情况中，运算符前后<strong>可能</strong>不加空格：</p><ul><li>考试即将结束时</li></ul></li><li><p>以下情况中，运算符前后<strong>不可能</strong>不加空格：</p><ul><li>除以上情况之外的所有情况</li></ul></li><li><p><code>typedef long long LL</code> 。</p></li></ul><h3 id="e-g"><a href="#e-g" class="headerlink" title="e.g."></a><em>e.g.</em></h3><p>（ <code>2-SAT</code> 模板节选）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int N &#x3D; 2e6 + 10;struct node &#123;    int u, v, next;    node() &#123;&#125;    node(int _u, int _v, int _next): u(_u), v(_v), next(_next) &#123;&#125;&#125; e[N];int h[N], tot &#x3D; 0;void add(int u, int v) &#123;    e[++tot] &#x3D; node(u, v, h[u]);    h[u] &#x3D; tot;&#125;int dfn[N], low[N], tag &#x3D; 0;int id[N], num &#x3D; 0;stack&lt;int&gt; s;int n, m;void tarjan(int u) &#123;    dfn[u] &#x3D; low[u] &#x3D; ++tag;    s.push(u);    for(int i &#x3D; h[u]; i; i &#x3D; e[i].next) &#123;        int v &#x3D; e[i].v;        if(dfn[v]) &#123;            if(!id[v]) low[u] &#x3D; min(low[u], dfn[v]);        &#125; else &#123;            tarjan(v);            low[u] &#x3D; min(low[u], low[v]);        &#125;    &#125;    if(dfn[u] &#x3D;&#x3D; low[u]) &#123;        id[u] &#x3D; ++num;        for(; s.top() !&#x3D; u; s.pop())             id[s.top()] &#x3D; num;        s.pop();    &#125;&#125;int main() &#123;        freopen(&quot;p4782.in&quot;, &quot;r&quot;, stdin);        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(int i&#x3D;1, _i, a, _j, b, u, v; i&lt;&#x3D;m; ++i) &#123;        scanf(&quot;%d%d%d%d&quot;, &amp;_i, &amp;a, &amp;_j, &amp;b);        u &#x3D; (_i-1)*2 + a, v &#x3D; (_j-1)*2 + b;        add(u^1, v);        add(v^1, u);    &#125;        for(int i&#x3D;0; i&lt;(n&lt;&lt;1); ++i)        if(!dfn[i]) tarjan(i);        for(int i&#x3D;0; i&lt;(n&lt;&lt;1); i+&#x3D;2) &#123;        if(id[i] &#x3D;&#x3D; id[i^1]) &#123;            printf(&quot;IMPOSSIBLE\n&quot;);            return 0;        &#125;    &#125;        printf(&quot;POSSIBLE\n&quot;);    for(int i&#x3D;0; i&lt;(n&lt;&lt;1); i+&#x3D;2)         printf(&quot;%d &quot;, id[i] &lt; id[i^1] ? 0 : 1);        return 0;&#125; </code></pre><h3 id="考场码风："><a href="#考场码风：" class="headerlink" title="考场码风："></a>考场码风：</h3><p>（牛客CSP-S提高组赛前集训营2 T3-维护序列 <code>2019.10.31</code>）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt; const int N &#x3D; 100005, INF &#x3D; 0x7fffffff;int abs(int x) &#123; return x &gt; 0 ? x : -x; &#125;int min(int a, int b) &#123; return a &gt; b ? b : a; &#125; struct node &#123;    int a, b, f, s;    node *l, *r;&#125; *root, pool[4*N]; struct pair &#123;    int l, r;&#125; tmpx[N], tmpy[N]; int id &#x3D; -1, cntx, cnty;int s[N];node *newnode(int a, int b) &#123;    pool[++id] &#x3D; (node) &#123;a, b, s[a], 0, NULL, NULL&#125;;    return &amp;pool[id];&#125; void build(node *&amp;root, int a, int b) &#123;    root &#x3D; newnode(a,b);    if(a&lt;b) &#123;        int mid &#x3D; (a+b) &gt;&gt; 1;        build(root-&gt;l, a, mid);        build(root-&gt;r, mid+1, b);        if(root-&gt;l-&gt;f &#x3D;&#x3D; root-&gt;r-&gt;f) root-&gt;f &#x3D; root-&gt;l-&gt;f;        else root-&gt;f &#x3D; 0;    &#125;&#125; bool check(node *root, int x) &#123;         if(root-&gt;f) return (root-&gt;f &#x3D;&#x3D; x);     bool s1 &#x3D; check(root-&gt;l, x);    bool s2 &#x3D; check(root-&gt;r, x);    return (s1 or s2);     &#125;  void edit(node *root, int a, int b, int x) &#123;    if(a &lt;&#x3D; root-&gt;a and root-&gt;b &lt;&#x3D; b) &#123;        root-&gt;f &#x3D; x;        return;    &#125;    if(root-&gt;f) &#123;        root-&gt;l-&gt;f &#x3D; root-&gt;f;        root-&gt;r-&gt;f &#x3D; root-&gt;f;        root-&gt;f &#x3D; 0;    &#125;    int mid &#x3D; (root-&gt;a + root-&gt;b) &gt;&gt; 1;    if(a &lt;&#x3D; mid) edit(root-&gt;l, a, b, x);    if(mid &lt; b) edit(root-&gt;r, a, b, x);&#125;bool query(node *root, int x, int y) &#123;         if(root-&gt;f) &#123;        if(root-&gt;f &#x3D;&#x3D; x) tmpx[++cntx] &#x3D; (pair) &#123;root-&gt;a, root-&gt;b&#125;;        else if(root-&gt;f &#x3D;&#x3D; y) tmpy[++cnty] &#x3D; (pair) &#123;root-&gt;a, root-&gt;b&#125;;        else return false;        return true;    &#125;         bool s1 &#x3D; query(root-&gt;l, x, y);    bool s2 &#x3D; query(root-&gt;r, x, y);         return (s1 or s2);&#125; inline int read() &#123;    char c &#x3D; getchar();    int x&#x3D;0, f&#x3D;1;    while(c &lt; &#39;0&#39; or c &gt; &#39;9&#39;) &#123; f &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? -1 : f; c &#x3D; getchar(); &#125;    while(c &gt;&#x3D;&#39;0&#39; and c &lt;&#x3D;&#39;9&#39;) &#123; x &#x3D; (x&lt;&lt;3) + (x&lt;&lt;1) + (c-&#39;0&#39;); c &#x3D; getchar(); &#125;    return x*f;&#125; int lastans &#x3D; 0;int main() &#123;         int n &#x3D; read(), m &#x3D; read(), flag &#x3D; read();    for(int i&#x3D;1; i&lt;&#x3D;n; ++i) s[i] &#x3D; read();    build(root, 1, n);         for(int ii&#x3D;1; ii&lt;&#x3D;m; ++ii) &#123;        if(!flag) lastans &#x3D; 0;        int opt &#x3D; read();        if(opt &#x3D;&#x3D; 1) &#123;            int l &#x3D; read()^lastans, r &#x3D; read()^lastans, x &#x3D; read()^lastans;            edit(root, l, r, x);        &#125;        if(opt &#x3D;&#x3D; 2) &#123;            int x &#x3D; read()^lastans, y &#x3D; read()^lastans;            if(x &#x3D;&#x3D; y) &#123;                bool f &#x3D; check(root, x);                lastans &#x3D; 0;                printf(&quot;%d\n&quot;, f ? 0 : -1);                continue;            &#125;            cntx &#x3D; cnty &#x3D; 0;            bool f &#x3D; query(root, x, y);            if(!f or !cntx or !cnty) &#123;                printf(&quot;-1\n&quot;);                lastans &#x3D; 0;                continue;            &#125;            lastans &#x3D; INF;            for(int i&#x3D;1; i&lt;&#x3D;cntx; ++i) &#123;                for(int j&#x3D;1; j&lt;&#x3D;cnty; ++j) &#123;                    lastans &#x3D; min(lastans, abs(tmpx[i].r - tmpy[j].l));                    lastans &#x3D; min(lastans, abs(tmpx[i].l - tmpy[j].r));                &#125;            &#125;            printf(&quot;%d\n&quot;, lastans);        &#125;             &#125;         return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 码风 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪</title>
      <link href="snow/"/>
      <url>snow/</url>
      
        <content type="html"><![CDATA[<iframe width=100% height=1024 frameborder=0 scrolling=yes src="https://cdn.jsdelivr.net/gh/SerokSSR/snow-pdf/snow-0706.pdf"></iframe><p>若文章在你的设备上无法正常显示，请<a href="https://cdn.jsdelivr.net/gh/SerokSSR/snow-pdf/snow-0706.pdf">点击此处</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 小说 &amp; 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Terminal · 番外</title>
      <link href="terminal-extra/"/>
      <url>terminal-extra/</url>
      
        <content type="html"><![CDATA[<h1 id="Terminal-·-番外"><a href="#Terminal-·-番外" class="headerlink" title="Terminal · 番外"></a>Terminal · 番外</h1><p>&emsp;&emsp;</p><p>他站在一片未知的天空里；他听到人的呐喊。</p><p>他看见了一群人，如同星星点点的火光，向着远处的一扇门去。</p><p>他看见了她。</p><p>&emsp;&emsp;</p><p>他感受着她的面颊：寒气如冰锥一般刺了进来。他睁开眼。</p><p><strong>她睁开眼。</strong></p><p>&emsp;&emsp;</p><p>他的心不禁悲凉起来了。</p><p>&emsp;&emsp;</p><p>她嫣然一笑，胜过所有盛开的花。</p><p>&emsp;&emsp;</p><p>她一次也没有回头。</p><p>&emsp;&emsp;</p><p><b>向她刮来；</b>从她的耳际掠过。</p><p>&emsp;&emsp;</p><p>海边。他在海边伫立着。</p><p>一阵风儿吹过。<strong>在他的眼前一闪。</strong></p><p>他终于叩了一下。</p><p>他试着喊了一声；无可弥补的梦。</p><p>&emsp;&emsp;</p><p>他向前探了探；一道雷池；。</p><p>&emsp;&emsp;</p><p><strong>在他的眼前一闪；。</strong></p><p>&emsp;&emsp;</p><p>他迟疑了一下。<b>两下？。</b></p><p>她加快了脚步。</p><p>&emsp;&emsp;</p><p>他哪里来的勇气？</p><p>&emsp;&emsp;</p><p><strong>她可还记得他？</strong></p><p>&emsp;&emsp;</p><hr><center>(EOF)</center><p>&emsp;&emsp;</p><ul><li>2019.11.16</li><li>CSP-S 2019 D1</li><li>心态爆炸（80/300）</li><li>AFO</li><li><code>//zsh ak ioi</code></li><li>WJH / LYZ</li><li><del>颓</del></li></ul>]]></content>
      
      
      <categories>
          
          <category> 小说 &amp; 随笔 </category>
          
          <category> 未来 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 Splay（一）</title>
      <link href="about-splay/"/>
      <url>about-splay/</url>
      
        <content type="html"><![CDATA[<h1 id="一、旋转（Zig-Zag）"><a href="#一、旋转（Zig-Zag）" class="headerlink" title="一、旋转（Zig - Zag）"></a>一、旋转（Zig - Zag）</h1><h2 id="1-右旋（Right-Rotation）"><a href="#1-右旋（Right-Rotation）" class="headerlink" title="1. 右旋（Right Rotation）"></a>1. 右旋（Right Rotation）</h2><p>观察每个节点的变化，其中每个节点都有指向其父节点的指针没有画出。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/splay1.png" alt="1.png"></p><p><strong>①②③</strong>处节点连接有变化。</p><h3 id="（1）-Q-的左子树修改为-P-的右子树的内容"><a href="#（1）-Q-的左子树修改为-P-的右子树的内容" class="headerlink" title="（1）$Q$ 的左子树修改为 $P$ 的右子树的内容"></a>（1）$Q$ 的左子树修改为 $P$ 的右子树的内容</h3><p>即 $B$ 成为 $Q$ 的左子树， $B$ 的父节点是 $Q$ 。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">q-&gt;left &#x3D; p-&gt;right; p-&gt;right-&gt;father &#x3D; q; </code></pre><p><strong>注意 P​ 可能没有右子树（即不存在 <code>P-&gt;right</code> 节点）。</strong></p><p>修改如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">q-&gt;left &#x3D; p-&gt;right; if(p-&gt;right !&#x3D; NULL) p-&gt;right-&gt;father &#x3D; q;</code></pre><h3 id="（2）-P-的右子树修改为-Q-，且同时-Q-的父节点修改为-P-。"><a href="#（2）-P-的右子树修改为-Q-，且同时-Q-的父节点修改为-P-。" class="headerlink" title="（2）$P$ 的右子树修改为 $Q$ ，且同时 $Q$ 的父节点修改为 $P$ 。"></a>（2）$P$ 的右子树修改为 $Q$ ，且同时 $Q$ 的父节点修改为 $P$ 。</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">p-&gt;right &#x3D; q; q-&gt;father &#x3D; p;</code></pre><p><strong>注意 Q 和 P 的左右子树有变化，所以 Q,P 的信息需要重新维护。</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">update(q); update(p); &#x2F;&#x2F;先Q后P</code></pre><h3 id="（3）-R-的子树应该修改为-P"><a href="#（3）-R-的子树应该修改为-P" class="headerlink" title="（3）$R$ 的子树应该修改为 $P$"></a>（3）$R$ 的子树应该修改为 $P$</h3><p>需要判断 $Q$ 是 $R$ 的哪种子树，左子树则 $P$ 给 $R$ 的左子树，否则给右子树。</p><p>全局变量 $root$ 记录树根。</p><p><strong>特判 $Q$ 有可能就是树根（即 $R$ 不存在）；</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if(r &#x3D;&#x3D; NULL) &#123;   p-&gt;father &#x3D; NULL; root &#x3D; p; return;&#125;if(q &#x3D;&#x3D; r-&gt;left) &#123;   r-&gt;left &#x3D; p; p-&gt;father &#x3D; r;&#125; else &#123;   r-&gt;right &#x3D; p; p-&gt;father &#x3D; r;&#125;</code></pre><p>整理一下，<strong>不管 Q​ 有无父节点，P 的父节点均修改为 Q 的父节点</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">p-&gt;father &#x3D; r;&#x2F;&#x2F;记录树根if(r &#x3D;&#x3D; NULL) &#123; root &#x3D; p; return; &#125;&#x2F;&#x2F;判断P连到R的那颗子树if(q &#x3D;&#x3D; r-&gt;left) r-&gt;left &#x3D; p; else r-&gt;right &#x3D; p; </code></pre><p><strong>Code :</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void right_rotate(node *p) &#123;    node *q &#x3D; p-&gt;father;     &#x2F;&#x2F;记录p的父节点    node *r &#x3D; q-&gt;father;     &#x2F;&#x2F;记录p的父节点的父节点    &#x2F;&#x2F;操作1    q-&gt;left &#x3D; p-&gt;right;     if(p-&gt;right !&#x3D; NULL) p-&gt;right-&gt;father &#x3D; q;    &#x2F;&#x2F;操作2    p-&gt;right &#x3D; q; q-&gt;father &#x3D; p;    &#x2F;&#x2F;维护节点信息（注意此处可暂不维护P）    update(q); &#x2F;&#x2F;update(p);    &#x2F;&#x2F;操作3    p-&gt;father &#x3D; r;    if(r &#x3D;&#x3D; NULL) &#123; root &#x3D; p; return; &#125;        if(q &#x3D;&#x3D; r-&gt;left) r-&gt;left &#x3D; p;     else r-&gt;right &#x3D; p;&#125;</code></pre><h2 id="2、左旋（Left-Rotation）"><a href="#2、左旋（Left-Rotation）" class="headerlink" title="2、左旋（Left Rotation）"></a>2、左旋（Left Rotation）</h2><p>同理右旋，只是<strong>①②</strong>不同。</p><p><strong>Code :</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void left_rotate(node *p) &#123;    node *q &#x3D; p-&gt;father;     &#x2F;&#x2F;记录p的父节点    node *r &#x3D; q-&gt;father;     &#x2F;&#x2F;记录p的父节点的父节点    &#x2F;&#x2F;操作1    q-&gt;right &#x3D; p-&gt;left;     if(p-&gt;left !&#x3D; NULL) p-&gt;left-&gt;father &#x3D; q;     &#x2F;&#x2F;操作2    p-&gt;left &#x3D; q; q-&gt;father &#x3D; p;    &#x2F;&#x2F;维护节点信息    update(q); &#x2F;&#x2F;update(p);    &#x2F;&#x2F;操作3    p-&gt;father &#x3D; r;    if(r &#x3D;&#x3D; NULL)&#123; root &#x3D; p; return; &#125;        if(q &#x3D;&#x3D; r-&gt;left) r-&gt;left &#x3D; p;     else r-&gt;right &#x3D; p;&#125;</code></pre><h2 id="3、双旋"><a href="#3、双旋" class="headerlink" title="3、双旋"></a>3、双旋</h2><p><strong>不断旋转 $X$ 节点，为了保证复杂度，需要连续旋转两次且旋转的次序不同。</strong></p><p>定义 $X$ 的父节点为 $Y$，$Y$ 的父节点为 $Z$。 </p><h3 id="（1）-X-和-Y-同时是其父节点的左子树或者同时是各自父节点的右子树（即同侧）。"><a href="#（1）-X-和-Y-同时是其父节点的左子树或者同时是各自父节点的右子树（即同侧）。" class="headerlink" title="（1）$X$ 和 $Y$ 同时是其父节点的左子树或者同时是各自父节点的右子树（即同侧）。"></a>（1）$X$ 和 $Y$ 同时是其父节点的左子树或者同时是各自父节点的右子树（即同侧）。</h3><p>这时我们要进行两次旋转，**先旋转 $Y$，再旋转 $X$**。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://i.loli.net/2020/02/14/ftNOzGvPhIg4HrT.png" alt="2.png"></p><p><strong>同左旋转演示图如下：</strong></p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://i.loli.net/2020/02/14/xpoeDuh3tVzCYy1.png" alt="3.png"></p><p><strong>同右旋转演示图如下：</strong></p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://i.loli.net/2020/02/14/keNpErmPRzwSufY.png" alt="4.png"></p><h3 id="（2）-X-和-Y-是其父节点的左、右子树，不同侧（即一左一右或一右一左）。"><a href="#（2）-X-和-Y-是其父节点的左、右子树，不同侧（即一左一右或一右一左）。" class="headerlink" title="（2）$X$ 和 $Y$ 是其父节点的左、右子树，不同侧（即一左一右或一右一左）。"></a>（2）$X$ 和 $Y$ 是其父节点的左、右子树，不同侧（即一左一右或一右一左）。</h3><p>这时我们只要 <strong>旋转两次 X​</strong> 即可。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://i.loli.net/2020/02/14/uqCdzUHN56bEPXI.png" alt="5.png"></p><h3 id="（3）判断-X-节点如何旋转。"><a href="#（3）判断-X-节点如何旋转。" class="headerlink" title="（3）判断 $X$ 节点如何旋转。"></a>（3）判断 $X$ 节点如何旋转。</h3><p><strong>$X$ 是其父节点的左子树则右旋，否则左旋。</strong></p><p>$X$ 若是它父节点左子树返回 <code>true</code>，否则返回 <code>false</code>：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool getlr(node *p) &#123;    return (p-&gt;father-&gt;left &#x3D;&#x3D; p);&#125;  &#x2F;&#x2F;选择合适的旋转方式void rotate(node *p) &#123;    if(getlr(p)) right_rotate(p);     else left_rotate(p);&#125;</code></pre><h1 id="二、旋转到根"><a href="#二、旋转到根" class="headerlink" title="二、旋转到根"></a>二、旋转到根</h1><p>将 $X$ 旋转到根是 <code>splay</code> 的关键，为了保证复杂度，<b>只要对 $X$ 节点操作，操作后就要将其旋转到根。</b></p><p> <em>如何旋转到根：</em> </p><ul><li><p>一步旋转就可以到根，进行单旋；</p></li><li><p>两步或两步以上，可以不断使用双旋。</p></li></ul><p>设计函数 <code>splay(p,q)</code> <strong>将 $P$ 旋转到 $Q$ 下方</strong>。</p><ul><li><code>q == NULL</code> 表示 $P$ 旋转到了根；</li><li>while $P$ 至少两次旋转才能到达：双旋；</li><li>if $P$ 还差一步满足条件：单旋。</li></ul><p><strong>Code :</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void splay(node *p, node *tar) &#123;      while(p-&gt;father !&#x3D; tar and p-&gt;father-&gt;father !&#x3D; tar) &#123;          if(getlr(p) &#x3D;&#x3D; getlr(p-&gt;father)) &#123;              rotate(p-&gt;father); rotate(p);          &#125; else &#123;              rotate(p); rotate(p);          &#125;      &#125;      if(p-&gt;father !&#x3D; tar) rotate(p);            update(p);  &#x2F;&#x2F;优化（避免重复维护）&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未来</title>
      <link href="future/"/>
      <url>future/</url>
      
        <content type="html"><![CDATA[<h1><center>未来</center></h1> <div class="note default flat"><p>“When you have that last piece of the jigsaw, everything will, I hope, be clear. . . .”</p></div><h2>「引子」</h2><p>我听着《我们仍不知道那年中美合拍的日子》，突然，章老师走了进来。我打开空气净化器，看了看垃圾桶里闪闪发光的律师函。</p><p>总之，故事就这样开始了。</p><hr><h2>「初雪」</h2><p>六老师签售会当天，现场热闹的很。</p><p>“六爷爷……孙悟空到底有几个女朋友啊？”</p><p>“所以我经常说，”章承恩回头望了望摄像机。“戏说不是胡说，改编不是乱编。……一个民族……文化……谢罪……拿着棒子这么走……”</p><p>这时，“啊——”的一声惨叫传来。六水线旁，一名男子倒在地上，已经没有了气息。</p><p>——</p><p>“死者名叫戴杉并，29 岁，在金猴皮鞋厂工作，不过似乎并不是他的主业。在他的电脑里，我们找到了很多线索表明这位海军上将……”三谷（Mitani）汇报道。</p><p>“行了行了，”我不耐烦地打断道，“我名侦探江户川（Edogawa）可不是来听你 × × 的。说吧，名单上还有谁？”</p><p>“你怎么知道……”三谷失声道。</p><p>“喂喂，”我敲了敲桌子，“就你这智商还想干这事？告诉你吧，作者看你蠢成这样，特意派我来带你走向人生巅峰的。所以，现在——”</p><hr><h2>「正宫」</h2><p>那天，我听闻杨洁导演去世了，准备好挽联，前去吊唁。</p><p>灵堂的气氛非常肃穆。那边六老师竟也换上了一袭黑衣，毕恭毕敬地垂下头，低声道：</p><p>“今年下半年……中美合拍……杨洁导演满意……多多支持。”</p><p>我沉痛地走出灵堂，外面的天已经黑了。天上的几颗星星闪着明灭的冷光。</p><p>我低头看了看手表：十三时二十六分。</p><p>难道是……？！</p><p>我缓而又缓地回过头。气势恢宏的大堂已经了无踪影。一望无际的原野上，章老师和几个吊唁的人似乎也意识到了什么，震悚地踅向四周。</p><p>突然，一道白痕闪了光，现了一个人，急匆匆地跑了过来。我看到他那惊愕之下掩着的笑意的脸，不禁一声哀叹：</p><p>“唉！又是这个蠢货！”</p><p>就在这时，高速跑动的他像是被什么绊了一下，“咚”地一声趴在了地上。</p><p>额……我不得不承认的是，虽然作者的确缺乏才华（很多时候都要靠我自己的演技），但在关键问题的处理上却是一点也不含糊。</p><p>我一边想着，一边向人群走去。</p><hr><h2>「Q&A」</h2><p>只听得章老师对着全国人民破口大骂道：</p><p>“等我回去以后，一个一个给你们寄律师函……对了，今年下半年……”</p> <div class="note default flat"><p>Question：人类的本质是什么？</p><p>Wrong Answer：复读机</p><p>Accepted：人类的本质是什么？</p></div><hr><h2>「设计实验」</h2><p>（好像又扯远了……说正事）</p><p>“必须灭杜！”桌对面的一个人大声喊道。我回过神来。</p><p>我皱起眉。那个名叫马三傻（Ma Wasabi）的人又来了。</p><p>旁边的那个人似乎也毫无兴致，一脸心不在焉地附和着。</p><p>“……灭杜使我成为一个完整的人。？”</p><p>“……啊？对对对，一点也不能剩。”上原（Uehara）答道。</p><p>“咦，怎么不见时川（Tokikawa）来？”我向邻座的新见（Shimmi）问道。他摇摇头。</p><p>“不知道。许是睡过头了吧。”</p><p>话虽这么说，但一个小时后，时川还没有下来。我因闲得无聊，便打开「神奇动物园」。这是一款专为睿智人群设计的高端手游，画面精良，很适合用来打发时间。</p><p>“时川还不下来？”工藤（Kudo）不耐烦道。</p><p>“要不上去看一下吧，”我提议道。</p><p>我同工藤到得他的房间口，敲了敲门。没有应声。</p><p>“等我给他打个电话。”工藤拿出寻呼机。电话铃响到第十三下时，他摇头。“没有人接。”</p><p>我们没有办法，只好找来了服务人员。我推开门：这里并没有人。</p><p>“他的背包还在，应该是没准备长时间外出的。”工藤道。</p><p>我点点头。看来也不会有什么发现了。“走吧，”我说道。</p><p>工藤和我正要离开之时，我的目光落在了浴室的门框上。门的合页上，圆珠笔迹的<strong>刻痕</strong>：</p><center>+ '5' (18) 65</center><p>？</p><p>我决定不再多想。</p><p> &emsp;</p><p>我们回到大厅。</p><p>“找到了吗？”五反田（Gotanda）问道。工藤摇头。</p><p>“已经十二点了，”高桥（Takahashi）道。“要不先吃饭吧。”</p><p> &emsp;</p><p>餐桌上的气氛非常肃穆。大家都默默吃着，seldom next 的两个人小声低语。时川到底去了哪里呢？</p><p>这时，店员端来了两面金黄的油炸哥布林。十数双筷子顿时一齐扑了过去。我没有动。</p><p>“天一……不来一块？”新见狼吞虎咽地吃着。</p><p>“奇怪，”我喃喃道，“总觉得有什么不对。”</p><p>“哪里不对了？我告诉你，完整的哥布林可是稀世珍品，难不成你想吃被滚木碾过一遍的？”他自谓幽默地笑笑，“快点吧，凉了就不好吃了。”</p><p>我取下一片，仔细检查一番；没有 clue。看来我的第六感最近也变得不准了啊，我苦笑着夹起放入嘴中。</p><p>——我呸呸几口吐了出来。“哥布林有毒！”</p><p>旁边的人惊诧地看了我一眼，随即也下意识地做了。</p><p>“什么？……有毒？”</p><p>“我们吃着什么事都没有呵……哪里有毒了？”</p><p>但我既不要无谓的辩解了。循着水木（Mizuki）惊惧的目光，工藤满口白沫地倒在了桌上，一下最后的抽搐。</p><hr><h2>「端口Ｉ」</h2><p>警察匆忙赶到现场。</p><p>“初步判断死者应该是死鱼（Diefish）氰化物中毒，”法医汇报道，“不过具体原因还要等解剖结果。”</p><p>他点点头。</p><p> &emsp;</p><p>警察和服务员简单地交谈了几句，走了。房间里笼罩着一团滞重的沉默。</p><p>“S 失踪了，Q 死了，”我自言自语道，“下一个就是我了。”</p><hr><h2>「DNS错误！」</h2><p>然而这个世界已不存在规则了。</p><hr><h2>「Loading . . .」</h2><p>“好嗨哟！”有人在我耳边喊道。</p><p>“嗨ニマ啊，要动手赶快！”我不满道。</p><p>“好的好的，”那人说着掏出一卷绳子。“我打算勒死你。不过分吧？”</p><p>“能换个更舒服的吗？这个绳子勒着好疼。”我问道。</p><p>他摇了摇头。“恐怕没有机会了。”</p><p>“喂！”已经喘不过气的我奋力嚷道。“剧本可不是这么写的！”</p><p>“我知道，”他平静地说。“你还有什么要说的吗？”</p><p>“你……”我很生气。</p><p>我边生气边想着明天早上吃什么。</p><hr><h2>「你们家的网炸了？」</h2><p>“江户川先生昨天晚上被人不改剧本就弄死了。”我悲伤地告诉了另外的几个人。</p><p>大家都非常惋惜。</p><hr><h2>「460？再见」</h2><p>两个月后。</p><p>我和高桥，新见，五反田四个人准时上了火车。</p><p>“出口竟然没被堵死，”我对新见说道。</p><p>“是啊；话说也真是的，十二个人最后就剩下了四个，连盘身份局都凑不齐……真是无聊。”新见摇头。</p><p>“对了，马三傻是怎么死的来着？”五反田（他似乎一直对这件事念念不忘）第 9102 次问道。</p><p>“唉，只有他死的最惨啊。你说是不是？”新见满脸泪光地笑了起来。</p><p>“没有办法……”我鼻子一酸。“他那天本来想去地沟弄点早点吃，结果刚一出门就让火车给撞死了……”我<strong>不由自主</strong>地哭了起来；高桥，新见，五反田也不甘示弱，一瞬间，整个车厢里哀嚎声，哭声，抽泣声，抹泪声揉作一团，是一浪高过一浪，过了好久，车厢里还回荡着一股海风的味道。</p><p>“三谷被人用诺基亚砸死了；R 上电梯时被从后面推了一下，掉到电梯井里摔死了；Y ……”五反田回忆道。</p><p>“对了，”高桥突然叫道，“还记得时川吗？”</p><p>“他可能永远都不会回来了。”我推开窗。</p><p>“为什么？”新见问道。只听得五反田似有似无的抽泣声。</p><p>“他去了另一个地方。”半晌，我长吁一口气。“一个更值得的 occasion。”</p><p>“比我们要去的这个地方更值得？”高桥问道。我用力点了点头。</p><p>之后的很长一段时间里没有人说话。</p><p><img src= "https://cdn.jsdelivr.net/gh/SerokSSR/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/SerokSSR/img/future1.png" alt="image-20200524131727707"></p><p>我久久地望向窗外。又是在这不经意的一刹，透过窗玻璃的反光，高桥指着我，对着正要说出什么惊天秘密似的新见使了个眼色。</p><p>我叹了口气。他们果然早已知道了一切。我所为之付的一番心血，并诩诩然以为天衣无缝的计划，不过是跳梁小丑罢了；一切都发生在那么短短的，不到十秒的时间里，可对我来说却像极了一生。</p><p>我的视线依然投在远方。看着看着，我渐渐不明白有多少东西可以称得上是变化了。<strong>世界本来就没有形状</strong>。</p><p>我想说些什么，但终究说不出口。我便一直是个如此懦弱的人。</p><p>即使是踏上这辆撞死了马三傻的火车。</p><p>“还有多长时间到？”高桥看了看手表。</p><p>“很快，”我答道。</p><p>“诶我突然有个想法，”五反田打起精神，“如果我们到站了还不下车，那么它会载我们到哪里？”</p><p>“向前。”</p><p>“Forever?”</p><p>“Yes.”</p><p>“可是……是你<strong>创造</strong>了这<strong>一切</strong>吧？”</p><p>我默然。新见好像打开了「神奇动物园」。</p><p>“Give him a rest 吧，”高桥说，“那些事不必再提了。”</p><p>我出神地望着车厢的一点。</p><p>“吱——”传来汽笛的轰鸣声。</p><p>“我们到了，”新见说。</p><p>太阳钻了出来。一阵熹微，暖融融地照在我们的脸上。</p><p>“I say . . . 我们应该给自己取个新名字吧？”五反田提议道，“毕竟西湖六月初嘛。我呢，就叫 MRC 好了。”</p><p>“我叫大辣鸡。”新见若有所思道。</p><p>“我叫大肥猪。”高桥毫不犹豫地说出了自己的心声。</p><p>“所以……你呢？”所有人的目光望向我。我惊了一下，笑容凝结在脸上。<strong>就在那边。</strong></p><p>我眨了眨眼；一切如故。</p><p><strong>原来我们是到了这里啊</strong>，我想道。不过也无所谓了。</p><p>新见和五反田 paradox 地对视着。</p><p>“天一有事吗……”高桥迟疑了一下，问道。</p><p>“没事没事，”我摆摆手，“刚才想事来着。”</p><p>太阳沉了下去。最初的一道光。</p><p>“高桥？”我唤道。她侧过脸。</p><p>“怎么啦？”</p><p>“早晨来临了。”</p><p> &emsp;</p><p>（BGM :ノルウェイの森）</p><p>（WOW）</p><p> &emsp;</p><p>（&lt;・)))&gt;&lt;&lt;）</p>]]></content>
      
      
      <categories>
          
          <category> 小说 &amp; 随笔 </category>
          
          <category> 未来 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星</title>
      <link href="star/"/>
      <url>star/</url>
      
        <content type="html"><![CDATA[<h1><center> 星</center></h1> <h2><center>The Star - Evolution</center></h2><p>&emsp;&emsp;</p><p>&emsp;&emsp;</p><p>&emsp;&emsp;早晨 6:30，C 起床。洗漱，吃饭，上学。</p><p>&emsp;&emsp;这样的生活已经持续了 10 年。</p><p>&emsp;&emsp;他走路去上学。</p><p>&emsp;&emsp;路上有几个行人；他们看起来很快乐。</p><p>&emsp;&emsp;“打王者一样能使我快乐呀，”他想。</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;他到了学校。一进教室，Peppa 迎了上来。</p><p>&emsp;&emsp;“昨天公孙离那把——你有点皮啊。”Peppa 满面红光，笑着说。</p><p>&emsp;&emsp;他也笑了笑，坐回座位，打开书包。</p><p>&emsp;&emsp;一声惨叫。</p><p>&emsp;&emsp;“Betsy！你昨天为什么没发语文笔记！”</p><p>&emsp;&emsp;“什么？哦！——”Betsy 掩面。“I’m really sorry.”</p><p>&emsp;&emsp;“别 sorry 了，赶紧拿来我抄——亏你还是代课表。”</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;S 走了进来。</p><p>&emsp;&emsp;教室里一片混乱。</p><p>&emsp;&emsp;代课表沉重而蹒跚的脚步声，组长催作业的叫嚷声，没交作业者的哭喊声，执勤班长杯水车薪的“Shh! ”声：一片大杂烩。</p><p>&emsp;&emsp;“同学们好。”S 提高了声音。</p><p>&emsp;&emsp;“老——师——好——”零零星星几个同学那里传来活无常似的叫声。</p><p>&emsp;&emsp;S 摇摇头。</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;L 正在讲课。</p><p>&emsp;&emsp;他的目光锁定了一个已经倒伏了半节课的学生。</p><p>&emsp;&emsp;“C：起来回答这道题。”</p><p>&emsp;&emsp;C 揉揉惺忪的睡眼。</p><p>&emsp;&emsp;“老…老师哪道题？”他有气无力地问道。</p><p>&emsp;&emsp;旁边，Betsy 用手使劲捅了他一下。“拼成边长 <code>sqrt(2) &lt;&lt; 1</code> 的正方形。”她低声说；他并没有听见。</p><p>&emsp;&emsp;“下午 4:00，家长来校。我亲自给你母亲打电话。坐。”</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;L 冷冷地说。</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;他站起身。</p><p>&emsp;&emsp;“他天天打王者，结果都玩了好几年了，段位还是钻石：我一个月前刚玩都已经上星耀了。”</p><p>&emsp;&emsp;“是；你知道为什么他最近一直没吃鸡吗？”</p><p>&emsp;&emsp;“愿闻其详。”</p><p>&emsp;&emsp;那人压低了声音。“他之前一直用外挂，被封号了。”他说。</p><p>&emsp;&emsp;“哦～；怪不得他之前……别说了。”另一个人看到他向他们瞥了一眼，连忙说道。</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;……</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;打发完朋友关切的质问，他独自一个人走在回家的路上。那天是愚人节，万家灯火，宝马雕车香满路。</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;他悚然一惊。</p><p>&emsp;&emsp;是，他看过余华的书，看过春生的戏份，知道活，有时孰难于死；可他也看过吴承恩的书，看过龙婆的戏份，知道好死不如赖活。</p><p>&emsp;&emsp;他停了下来。</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;“今天是星期五啊，”他突然想起，“我可以在外面待到8点的。现在还早的很。”</p><p>&emsp;&emsp;街上大包小包的人群；他们很快乐。</p><p>&emsp;&emsp;快乐是什么？</p><p>&emsp;&emsp;上个月考过一篇作文：</p><p>&emsp;&emsp;《那天，我捡到了快乐的钥匙》。他写的是他登上了王者全服第一。他知道，这次作文又要得D了。</p><p>&emsp;&emsp;可是……</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;？</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;他找到一条长凳，坐了下来。</p><p>&emsp;&emsp;天空中现出一道橘光。他睁大双眼。</p><p>&emsp;&emsp;“哇！流星！”几个人喊道。</p><p>&emsp;&emsp;绝望攫住了他的心。心中却并不是一片黑暗。</p><p>&emsp;&emsp;世上的牵挂……Maybe Betsy？Or Daniel？Kamen？</p><p>&emsp;&emsp;But, am I really their friend? Or I should say, are they really my friends?</p><p>&emsp;&emsp;Seems not. （我似乎变的豁达了。）</p><p>&emsp;&emsp;他摇了摇头。</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;他站起身。空气中弥漫着违和的气氛。</p><p>&emsp;&emsp;他似乎能够感受到那拼命想要置他于死地的虚空。</p><p>&emsp;&emsp;“谢谢你，”他说。</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;“你不能这样！”</p><p>&emsp;&emsp;“为什么？”</p><p>&emsp;&emsp;“你还没上星耀！”</p><p>&emsp;&emsp;星耀？他想。那不是我一直的理想吗？为什么我现在对此却这样木然？</p><p>&emsp;&emsp;流星雨还在下。</p><p>&emsp;&emsp;一道星光射向他的心间。他的心忽而苏生了过来。</p><p>&emsp;&emsp;他闭上眼。</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;“没有涅槃，也没有收获罢。”</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;他转身；他消失在白夜中。</p><p>   &emsp;&emsp;    </p><p>&emsp;&emsp;——</p><p> &emsp;&emsp;</p><p>&emsp;&emsp;“I got the story, ”他举起一张纸, “From his will. ”</p><p>&emsp;&emsp;Betsy 脸上铺满泪水。Daniel 仍然绷着那张死鱼脸，只是嘴角向上微微翘了翘。Scistar “扑通”一声倒在了地上。</p><p>&emsp;&emsp;只有 Supreme 似乎毫无反应。</p><p>&emsp;&emsp;“你还早两万年呢，”他说。</p><p>&emsp;&emsp;</p><div class="note default flat"><p>一八，四，五，津沽。</p></div>]]></content>
      
      
      <categories>
          
          <category> 小说 &amp; 随笔 </category>
          
          <category> 星 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小说 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于自己</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Profile-側影"><a href="#Profile-側影" class="headerlink" title="Profile 側影"></a>Profile 側影</h2><h3 id="Basic-Info-概要"><a href="#Basic-Info-概要" class="headerlink" title="Basic Info 概要"></a>Basic Info 概要</h3><p>&emsp;Hometown：天津</p><p>&emsp;破壳年：2004</p><p>&emsp;星座：巨蟹座 Cnc</p><p>&emsp;职业：创作者、读者、高玩、云玩家、OIer、学生、……</p><p>&emsp;Admiration：村上春树、汪曾祺、曹雪芹、宫崎骏、余华、J.K.Rowing、……</p><p>&emsp;Favorite：<em><b>1Q84</b></em></p><p>&emsp;工作单位：天津市第一中学</p><p>&emsp;职称：高一</p><p>&emsp;Contact：<i class="fab fa-qq"></i> 3091742436</p><h3 id="Reality-現實"><a href="#Reality-現實" class="headerlink" title="Reality 現實"></a>Reality 現實</h3><table><thead><tr><th align="center">2018.7</th><th align="center">入坑</th><th align="center">?</th><th align="center">我要 AK IOI</th></tr></thead><tbody><tr><td align="center">2018</td><td align="center">NOIp - PJ</td><td align="center">1=</td><td align="center">?</td></tr><tr><td align="center">2019</td><td align="center">CSP - S2</td><td align="center">2=</td><td align="center">没脸见人</td></tr></tbody></table><h3 id="Fantasy-夢裏"><a href="#Fantasy-夢裏" class="headerlink" title="Fantasy 夢裏"></a>Fantasy 夢裏</h3><table><thead><tr><th align="center">2020</th><th align="center">NOIp - TG</th><th align="center">全国前 <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>20%</mn></math></th><th align="center"><strong>頑張って!</strong></th></tr></thead><tbody><tr><td align="center">2021</td><td align="center">NOI</td><td align="center">?</td><td align="center"><strong>頑張って!</strong></td></tr></tbody></table><h2 id="Log-日誌"><a href="#Log-日誌" class="headerlink" title="Log 日誌"></a>Log 日誌</h2><h3 id="2020-07-2020-08"><a href="#2020-07-2020-08" class="headerlink" title="2020.07 ~ 2020.08"></a>2020.07 ~ 2020.08</h3><h4 id="2020-8-19"><a href="#2020-8-19" class="headerlink" title="2020.8.19"></a>2020.8.19</h4><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>调整字号</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>代码框工具栏调整为 MAC 样式</p>            </div><h4 id="2020-8-13"><a href="#2020-8-13" class="headerlink" title="2020.8.13"></a>2020.8.13</h4><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>再次调整配色方案</p>            </div><h4 id="2020-8-12-▽"><a href="#2020-8-12-▽" class="headerlink" title="2020.8.12 (*^▽^*)"></a>2020.8.12 (*^▽^*)</h4><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>异步加载非必要 CSS，渲染速度大幅提升</p>            </div><p>&emsp;移动端 Lighthouse 跑分由 18 提升至 69，桌面端由 48 提升至 94<br>&emsp;首次内容绘制时间降至 1.1 秒 (Desktop)，3.8秒(Mobile)</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>博客被百度收录</p>            </div><h4 id="2020-8-11"><a href="#2020-8-11" class="headerlink" title="2020.8.11"></a>2020.8.11</h4><div class='checkbox blue checked'><input type="radio" checked="checked"/>            <p>评论系统更换为 Valine</p>            </div><h4 id="2020-7-26"><a href="#2020-7-26" class="headerlink" title="2020.7.26"></a>2020.7.26</h4><div class='checkbox checked'><input type="radio" checked="checked"/>            <p><a href="https://snow.js.org/lete">樂特全球後援會</a> 正式创立</p>            </div><h4 id="2020-7-14-🎁-16th-BIRTHDAY"><a href="#2020-7-14-🎁-16th-BIRTHDAY" class="headerlink" title="2020.7.14 🎁 16th BIRTHDAY!"></a>2020.7.14 🎁 16th BIRTHDAY!</h4><div class='checkbox minus cyan checked'><input type="checkbox" checked="checked"/>            <p>这一天是 SerokSSR 的生日！(*^▽^*)</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>更换托管网站，部署在 <a href="https://snow.js.org/hexo-vercel/">Vercel</a></p>            </div><h4 id="2020-7-9"><a href="#2020-7-9" class="headerlink" title="2020.7.9"></a>2020.7.9</h4><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>域名更换为 snow.js.org</p>            </div><h4 id="2020-7-2020-8"><a href="#2020-7-2020-8" class="headerlink" title="2020.7 ~ 2020.8"></a>2020.7 ~ 2020.8</h4><div class="note default flat"><p>生生繁華于枯荑<br>萋萋空翠自灵犀<br>輝星皓夜蒼千頃<br>此宵風醉月舞螢</p></div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>为 Butterfly 主题贡献两次PR(Merged)</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>开启 PWA</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>开启 Pjax</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>开启 Aplayer</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>开始使用<a href="https://www.antmoe.com/">小康</a>的魔改</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>开始自己魔改</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>使用 GitHub + jsDelivr图床</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>在多种评论系统间反复横跳</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>And More. . . .</p>            </div><h3 id="2020-3-2020-6-上学"><a href="#2020-3-2020-6-上学" class="headerlink" title="2020.3 ~ 2020.6 上学"></a>2020.3 ~ 2020.6 上学</h3><div class="note default flat"><p>他可能还没有想到过那样的一天，雪花浸满了每一个角落。空自，他守望着梦乡。</p></div><h3 id="2020-2"><a href="#2020-2" class="headerlink" title="2020.2"></a>2020.2</h3><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>入坑 Hexo</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>入坑 Butterfly</p>            </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="friends/index.html"/>
      <url>friends/index.html</url>
      
        <content type="html"><![CDATA[<p>本页面暂不添加新的友链，可至 <a href="https://snow.js.org/friends/">https://snow.js.org/friends/</a> 申请。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
